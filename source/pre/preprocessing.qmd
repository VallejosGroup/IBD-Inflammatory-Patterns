---
title: "Preprocessing"
author:
  - name: "Nathan Constantine-Cooke"
    corresponding: true
    url: https://scholar.google.com/citations?user=2emHWR0AAAAJ&hl=en&oi=ao
    affiliations:
      - ref: CGEM
      - ref: HGU
  - name: "Karla Monterrubio-Gómez"
    url: https://scholar.google.com/citations?user=YmyxSXAAAAAJ&hl=en
    affiliations:
      - ref: HGU
      - ref: CGEM
  - name: "Nikolas Plevris"
    affiliations:
      - ref: CGEM
      - ref: IBD
  - name: "Matthew Lyons"
    url: https://scholar.google.com/citations?user=I9vcMcQAAAAJ&hl=en&oi=ao
    affiliations:
      - ref: IBD
  - name: "Charlie W. Lees"
    url: https://scholar.google.com/citations?user=rHc0qf0AAAAJ&hl=en&oi=ao
    affiliations:
      - ref: CGEM
      - ref: IBD
  - name: "Catalina A. Vallejos"
    url: https://scholar.google.com/citations?user=lkdrwm0AAAAJ&hl=en&oi=ao
    affiliations:
      - ref: HGU
      - ref: Turing
#comments:
#  giscus: 
#    repo: quarto-dev/quarto-docs
editor_options: 
  markdown: 
    wrap: 72
---

## Introduction

```{R Package load}
#| message: false
#| warning: false
set.seed(123)
### Required packages
library(tidyverse) # ggplot2, dplyr, and magrittr
library(knitr) # Markdown utilities
library(pander) # Pretty markdown rendering
library(datefixR) # Standardising dates
library(lubridate) # Date handling
library(patchwork) # Arranging plots
```

This page details preprocessing steps undertaken prior to model fitting.
These steps include examining data quality, performing data cleaning,
and deriving the study cohort.

The biomarker (FC and CRP) data used in this pipeline have been
primarily obtained from TRAK, a system used by NHS Lothian for the
electronic ordering of laboratory tests. However, we also use
phenotyping data manually curated by the Lees group for previous studies
(see @Jenkinson2020).

Prior to this report, all subject CHI (community health index) numbers,
which uniquely identifies a patient when they interact with NHS Scotland
services, were pseudoanonymised. Each CHI has been replaced with a
unique random number.

### Inclusion/exclusion criteria definitions {#inclusionexclusion-criteria-definitions}

The inclusion criteria for this study can broadly be categorised into
two classifications: baseline and longitudinal. Baseline criteria can be
applied using information known at diagnosis whilst longitudinal
criteria are based on biomarker measurements taken over time.

The longitudinal criteria for each biomarker (FC and CRP) are considered
independently. If a subject meets the below criteria for FC but not CRP,
then only the FC for the subject will be modelled and vice versa.

::: panel-tabset
#### Baseline

##### Diagnosis of Inflammatory bowel disease

As inflammatory bowel disease (IBD) is the disease of interest for this
study, subjects are required to have a confirmed diagnosis of either
Crohn's disease, ulcerative colitis, or inflammatory bowel disease
unclassified.

##### Diagnosis date

Study subjects are required to have been diagnosed with IBD between
October 2004 and December 2017. The lower bound is required as FC tests
were not introduced until 2005 and we require study subjects to have a
FC available close to diagnosis (see the longitudinal tab). The upper
bound is required to ensure subjects have the opportunity to have at
least five years of follow-up. The most recent FC observation in this
dataset is January 2023 which informed when deciding upon this cut-off.

#### Longitudinal

##### Diagnostic measurement

We require study subjects to have a biomarker measurement taken ±90 days
of reported date of diagnosis.

##### At least three non-censored measurements

To ensure stability and interpretability, study subjects are also
required to have at three non-censored biomarker measurements taken
across follow-up. Like most biomarkers, the biomarkers used in this
study are subject to censoring. However, these censored observations
make it impossible to detect changes over time and we therefore do not
wish to be reliant on censored observations.
:::

### Datasets

```{R Read files}
if (file.exists("/.dockerenv")) { # Check if running in Docker
  # Assume igmm/Vallejo-predict/libdr/ is passed to the data volume
  prefix <- "data/"
} else {
  # Assume running outside of a Docker container and the IGC(/IGMM) datastore is
  # mounted at /Volumes
  prefix <- "/Volumes/igmm/cvallejo-predicct/libdr/"
}

fcal.pheno <- read.csv(file.path(prefix, "2024-10-03/fcal-cleaned.csv"))

# Extract from TRAK which also now introduces CRP.
labs <- read.csv(file.path(prefix, "2024-10-03/markers-cleaned.csv"))
fcal <- subset(labs, TEST == "f-Calprotectin-ALP")

# Add sex and diagnosis type from fcal.pheno
fcal <- fcal.pheno %>%
  distinct(ids, .keep_all = TRUE) %>%
  select(ids, sex, diagnosis, diagnosis_date) %>%
  merge(x = fcal, by = "ids", all.x = TRUE, all.y = FALSE)

# labs prefix not required for crp as labs is the only crp extract
crp <- subset(labs, TEST == "C-Reactive Prot")
updated <- read.csv(file.path(prefix, "2024-10-03/allPatientsNathanCleaned.csv"))
outcomes <- read.csv(file.path(prefix, "2024-10-03/cd-cleaned.csv"))
```

Multiple datasets are used in this report with varying degrees of
previous curation.

-   `markers.csv` is a 2024 extraction from TRAK describing
    `r nrow(labs)` test results (FC: `r nrow(fcal)`; CRP:
    `r nrow(crp)`). Each row represents a test result with columns
    indicating the corresponding subject ID, the test type (FC or CRP),
    the time of the test, and the test result. This dataset contains the
    most recent data out of the other datasets. However, there has been
    no manual curation of these data, and no information about the
    patient's characteristics are available (other than their ID).
-   `fcal-cleaned.csv` does not describe CRP data. However, these data
    have been curated by the Lees group and includes additional FC
    results. These are likely from other studies which involved FC data,
    such as [PREdiCCt](https://www.predicct.co.uk). In addition to
    `r nrow(fcal)` FC test results, each row also provides the sex, IBD
    type, date of diagnosis, and date of death (if applicable) for the
    corresponding subject.
-   `allPatientsNathanCleaned.csv` provides sex, IBD type, and diagnosis
    date for most (but not all) subjects in `labs.csv` not described by
    `fcal-cleaned.csv`.
-   `cd-cleaned.csv` describes CD patient data (n = `r nrow(outcomes)`).
    In addition to the same basic patient characteristic variables in
    other datasets, this dataset also describes surgical outcomes and
    biologic treatments prescribed to the subject.

::: callout-note
The "cleaned" in the above file names refers to the CHI numbers having
been replaced. No further processing of the data has been undertaken for
this study prior to the steps outlined in this report.
:::

## Subject data

We will create a "dictionary" which, for each subject, lists their
subject ID, their IBD type, and their date of diagnosis. In addition to
ensuring inclusion criteria are met, date of diagnosis will be used to
retime all biomarker measurements of a subject such that $t=0$
corresponds to their diagnosis date. IBD types are used to test if
clusters are enriched by IBD type and may be used to adjust the
clustering.

There are multiple potential sources for date of diagnosis and IBD type:
the CD outcomes dataset, a demographics dataset maintained by the Lees
group, and a raw TRAK extraction. For every subject listed in at least
one of these datasets, we have tried to extract their date of diagnosis
and diagnosis type. We have assumed a hierarchy of datasets where
manually curated datasets are preferred for extracting data over a
dataset generated with minimal human involvement.

### Diagnosis and diagnosis date

```{R Create subject dictionary}
ids <- unique(c(outcomes$ids, fcal$ids, updated$ids))
diagnosis <- character()
date.of.diag <- character()
for (id in ids) {
  if (id %in% outcomes$ids) {
    # Outcomes data only contains CD subjects
    diagnosis <- c(diagnosis, "Crohn's Disease")
    date.of.diag <- c(
      date.of.diag,
      subset(outcomes, ids == id)$diagnosisDate
    )
  } else if (id %in% updated$ids) {
    diagnosis <- c(diagnosis, subset(updated, ids == id)[1, "diagnosis"])
    date.of.diag <- c(
      date.of.diag,
      subset(updated, ids == id)[1, "diagnosisDate"]
    )
  } else if (id %in% fcal$ids) {
    diagnosis <- c(diagnosis, subset(fcal, ids == id)[1, "diagnosis"])
    date.of.diag <- c(
      date.of.diag,
      subset(fcal, ids == id)[1, "diagnosis_date"]
    )
  } else {
    diagnosis <- c(diagnosis, "Unknown")
    date.of.diag <- c(
      date.of.diag,
      "Unknown"
    )
  }
}

dict <- data.frame(
  ids = ids,
  diagnosis = diagnosis,
  date.of.diag = fix_date_char(date.of.diag)
)

rm(id, ids, diagnosis, date.of.diag) # clean up
dict <- fix_date_df(dict, "date.of.diag")
```

Before filtering by inclusion/exclusion criteria, there are
`r sum(is.na(dict$date.of.diag))` individuals for which a diagnostic
date is missing. However, `r sum(is.na(dict$diagnosis))` missing values
are observed for diagnosis (IBD type). 

As can be seen in the below table, two spellings of Crohn's disease (with and 
without an apostrophe ("'")) and three names for IBDU are used. There are also 
subjects reported to not have IBD. The latter will be removed, leaving 
`r sum(dict$diagnosis != "Not IBD")` to be included in subsequent analyses.

```{R Frequency table to diagnosis pre-process}
#| label: tbl-diag-pre
#| tbl-cap: Frequency table of reported IBD type
kable(unique(dict$diagnosis),
  col.names = c("Diagnosis")
)

dict <- dict %>% subset(diagnosis != "Not IBD")
```

The Crohn's disease and IBDU names have been standardised (IBDU,
Inflammatory Bowel Disease, Inflammatory Bowel Disease - Unknown Subtype
are assumed to be equivalent). The subject reported to not have IBD has
been removed.

```{R Contingency table of IBD diagnosis pre and post processing}
#| label: tbl-diag-post
#| tbl-cap: Contingency table showing mapping of IBD types to a standardised format
#| results: "hold"
dict$old <- dict$diagnosis
dict$diagnosis <- plyr::mapvalues(
  dict$diagnosis,
  from = c(
    "Crohns Disease",
    "Inflamatory Bowel Disease",
    "Inflamatory Bowel Disease - Unknown Subtype"
  ),
  to = c(
    "Crohn's Disease",
    "IBDU",
    "IBDU"
  )
)

kable(addmargins(table(dict$diagnosis, dict$old), margin = 2))
dict$old <- NULL

dim(dict)
```

### Age and sex

```{r add sex to dict}
# Merge with fcal to add sex information
dict <- fcal.pheno[,c("ids", "sex")] %>%
  distinct(ids,
           .keep_all = TRUE) %>%
  merge(x = dict, by = "ids", all.x = TRUE, all.y = FALSE)

# Update NA sex if sex available from updated
dict <- merge(dict,
              updated[, c("ids", "sex")],
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) 

for (i in 1:nrow(dict)){
  if (is.na(dict[i, "sex.x"]) & !is.na(dict[i, "sex.y"])) {
    dict[i, "sex.x"] <- dict[i, "sex.y"]
  }
}

dict$sex <- dict$sex.x
dict$sex.x <- dict$sex.y <- NULL

# Add age at IBD diagnosis
updated <- fix_date_df(updated, "diagnosisDate")
updated$age <- with(updated, year(diagnosisDate) - dateOfBirth)
dict <- merge(dict,
              updated[, c("ids", "age")],
              by = "ids",
              all.x = TRUE,
              all.y = FALSE)

dim(dict)
```

Note that there `r sum(is.na(dict$age))` individuals for which age at
diagnosis is missing (this is due to missing diagnostic dates). However,
there are `r sum(is.na(dict$sex))` individuals for which sex is missing.

### Date of death

```{r add date.of.death}
dict <- merge(dict,
              updated[, c("ids", "death")],
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(date.of.death = death)

dict <- fix_date_df(dict, "date.of.death")
dim(dict)
```

Date of death information is available for
`r sum(!is.na(dict$date.of.death))` individuals. We assume that all
remaining individuals have not died by the date of data extraction.

## Exploration of data disagreements

<!--- CAV: Remove this from the final website as it shows small counts ---> 

```{R Create subject dictionary alternative}
# From outcomes
dict <- merge(dict,
              outcomes[, c("ids", "diagnosisDate")],
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(date.of.diag.outcomes = diagnosisDate)
dict <- fix_date_df(dict, "date.of.diag.outcomes")
dim(dict)

# From updated
dict <- merge(dict,
              updated[, c("ids", "diagnosisDate")],
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(date.of.diag.updated = diagnosisDate)
dict <- fix_date_df(dict, "date.of.diag.updated")
dim(dict)

# From fcal
dict <- merge(dict,
              fcal[, c("ids", "diagnosis_date")] %>% distinct(ids, .keep_all = TRUE),
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(date.of.diag.fcal = diagnosis_date)
dict <- fix_date_df(dict, "date.of.diag.fcal")
dim(dict)
```

```{R Create subject dictionary alternative sex}
# From outcomes
dict <- merge(dict,
              outcomes[, c("ids", "Gender")],
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(sex.outcomes = Gender)
dim(dict)

# From updated
dict <- merge(dict,
              updated[, c("ids", "sex")],
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(sex.updated = sex.y, sex = sex.x)
dim(dict)

# From fcal
dict <- merge(dict,
              fcal[, c("ids", "sex")] %>% distinct(ids, .keep_all = TRUE),
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(sex.fcal = sex.y, sex = sex.x)
dim(dict)

table(dict$sex.outcomes, dict$sex.updated, useNA = "always")
table(dict$sex.outcomes, dict$sex.fcal, useNA = "always")
table(dict$sex.updated, dict$sex.fcal, useNA = "always")
```

::: column-page
```{R Create subject dictionary alternative diag}
# From outcomes
dict <- merge(dict,
              outcomes[, c("ids", "diagnosisId")],
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(diagnosis.outcomes = diagnosisId)
dim(dict)

# From updated
dict <- merge(dict,
              updated[, c("ids", "diagnosis")],
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(diagnosis = diagnosis.x,
         diagnosis.updated = diagnosis.y)
dim(dict)

# From fcal
dict <- merge(dict,
              fcal[, c("ids", "diagnosis")] %>% distinct(ids, .keep_all = TRUE),
              by = "ids",
              all.x = TRUE,
              all.y = FALSE) %>% 
  rename(diagnosis = diagnosis.x,
         diagnosis.fcal = diagnosis.y)
dim(dict)

table(dict$diagnosis.outcomes, dict$diagnosis.updated, useNA = "always")
table(dict$diagnosis.outcomes, dict$diagnosis.fcal, useNA = "always")
table(dict$diagnosis.updated, dict$diagnosis.fcal, useNA = "always")
```
:::

```{r explore differences in diagnostic date, eval = FALSE}
table(year(dict$date.of.diag.outcomes) - year(dict$date.of.diag.updated))
table(year(dict$date.of.diag.outcomes) - year(dict$date.of.diag.fcal))
table(year(dict$date.of.diag.updated) - year(dict$date.of.diag.fcal))

ids1 <- dict$ids[which(year(dict$date.of.diag.outcomes) - year(dict$date.of.diag.updated) < -10)]

dict %>% subset(ids %in% ids1)
dict %>% subset(!is.na(date.of.death))

par(mfrow = c(1,3))
with(dict, plot(date.of.diag.outcomes, date.of.diag.updated))
abline(a = 0, b = 1, col = "red")

with(dict, plot(date.of.diag.outcomes, date.of.diag.fcal))
abline(a = 0, b = 1, col = "red")

with(dict, plot(date.of.diag.updated, date.of.diag.fcal))
abline(a = 0, b = 1, col = "red")

par(mfrow = c(1,3))
with(dict, plot(date.of.death, date.of.diag.updated))
abline(a = 0, b = 1, col = "red")

with(dict, plot(date.of.death, date.of.diag.outcomes))
abline(a = 0, b = 1, col = "red")

with(dict, plot(date.of.death, date.of.diag.fcal))
abline(a = 0, b = 1, col = "red")
```

## Exclusion criteria according to diagnosis and date of diagnosis

Date of diagnosis in an integral aspect of the inclusion criteria and
also used to retime biomarker measurements.

Firstly, we remove `r sum(is.na(dict$date.of.diag))` individuals with a missing date of diagnosis. 

```{R Remove NA date of diagnosis}
dict <- dict[!is.na(dict$date.of.diag), ]

dim(dict)
```

This leaves `r nrow(dict)` for subsequent analyses. 

```{R Apply date of diagnosis exclusion}
# no. subjects over upper bound
max_fup <- max(labs$COLLECTION_DATE)
max_fup <- as.Date(max_fup)
n.upper <- nrow(subset(dict, max_fup - date.of.diag  < 5 * 365.25))

# no. subjects under lower bound
n.lower <- nrow(subset(dict, (year(date.of.diag) < 2004) |
  (year(date.of.diag) == 2004 & month(date.of.diag) <= 9)))

# subset to subjects meeting the criteria.
dict <- subset(dict, max_fup - date.of.diag >= 5 * 365.25)
dict <- subset(dict, (year(date.of.diag) >= 2005) |
  (year(date.of.diag) == 2004 & month(date.of.diag) >= 10))

dim(dict)
```

As described in the [inclusion/exclusion criteria
section](#inclusionexclusion-criteria-definitions), the inclusion criteria 
considers upper and lower bounds for the diagnostic dates. In this case, we
only consider subjects diagnosed after October 2004 and 13 August 2019 (this
ensures individuals can be followed up by at least 5 year by the time of the
last longitudinal measument obtained for the cohort; `r max_fup`). As
such, subjects who do not meet this criteria will be excluded.
`r n.upper` subjects were diagnosed on 13 August 2019 or later and were removed,
and `r n.lower` subjects were diagnosed prior to October 2004 and were
likewise removed. This results in a cohort size of `r nrow(dict)`
subjects.

```{R Clean up excluded date of diagnosis counts}
#| include: false
rm(n.upper, n.lower) # clean up
```


## Exploration

<!--- CAV: we should move this into an EDA script ---> 

We now explore date of diagnosis to ensure data quality is at a suitable
standard.

##### Year of diagnosis

From @fig-diag-year, we can see the number of IBD diagnoses each year is
relatively static with the exception of 2004 and 2005. The former
describes only three months of the year, and incidence was likely still
increasing across both of these two years. @Jones2019 found IBD
incidence from 2008 onwards to be consistent over time for patients
diagnosed by NHS Lothian which is in agreement with our findings.

```{R Year of diagnosis}
#| label: fig-diag-year
#| fig-cap: "Distribution of year of diagnosis"
dict %>%
  ggplot(aes(x = year(date.of.diag))) +
  geom_histogram(fill = "#B8F2E6", color = "black", binwidth = 1) +
  theme_minimal() +
  xlab("Year of IBD diagnosis") +
  ylab("Frequency")
```

##### Month of diagnosis

It appears there are subjects for whom only year of diagnosis was
available. This has resulted in the 1<sup>st</sup> of January for that
year being recorded as the date of diagnosis for that subject. As such,
far more diagnoses are reported in January than in other months
(@fig-diag-month). There are
`r sum(day(dict$date.of.diag) == 1 & month(dict$date.of.diag) == 1)`
subjects reported to have been diagnosed on New Year's day .

If a subject's exact date of diagnosis is not known, then this is most
likely because the subject was not diagnosed by NHS Lothian. Instead,
the date of diagnosis would have needed to be recalled by the subject
which introduces the inaccuracy observed.

As subjects are require a diagnostic biomarker measurement to be
available within 90 days of reported date of diagnosis to be included in
this study and patients diagnosed outside of NHS Lothian will not have a
biomarker test result available within this period, the effect on our
study should be minimal. However, we will revisit month of diagnosis
after filtering by existence of diagnostic biomarker measurements to
confirm our assumption.

```{R Year of diagnosis (preprocessed)}
#| label: fig-diag-year-processed
#| fig-cap: "Bar plot of year of diagnosis"
dict %>%
  ggplot(aes(x = as.factor(year(date.of.diag)))) +
  geom_bar(color = "black", fill = "#FEC601", linewidth = 0.3) +
  theme_minimal() +
  ylab("Frequency") +
  xlab("Year of IBD Diagnosis")
```

```{R Month of diagnosis (preprocessed)}
#| label: fig-diag-month
#| fig-cap: "Bar plot of month of diagnosis"
dict %>%
  ggplot(aes(x = as.factor(month(date.of.diag, label = TRUE)))) +
  geom_bar(color = "black", fill = "#FEC601", linewidth = 0.3) +
  theme_minimal() +
  ylab("Frequency") +
  xlab("Month of IBD Diagnosis")
```

```{r diagnostic trend}
diag.ts <- dict %>% 
  mutate(date.of.diag.month = 
           as.Date(paste0(format(date.of.diag, "%Y-%m"), "-01"), format = "%Y-%m-%d")) %>%
  group_by(date.of.diag.month) %>%
  summarise(count = n()) %>%
  ungroup() 

ggplot(diag.ts, aes(x = as.Date(date.of.diag.month, "%Y-%m"), y = count, group = 1)) +
  geom_line() +
  xlab("Diagnosis date") + 
  ylab("Number of diagnosis") +
  scale_x_date(date_labels = "%Y-%m") +
  theme_minimal()
```

## Faecal calprotectin

Faecal calprotectin (FC), a marker of intestinal inflammation, has been
obtained from two datasets. The first dataset has been curated by
members of the Lees group whilst the second dataset is a direct extract
from TRAK, a patient monitoring system used by NHS Lothian.

### Incorporating later extract

Data from these datasets has been merged and duplicates of data (same
subject ID, measurement date, and recorded value) were removed. We also
reduced the FC dataset to only describe subjects for whom IBD type and
date of diagnosis are available for.

For the TRAK extract, times for test results are given in datetime
format (where both date and time of the day are provided). The times
have been dropped as this degree of granularity is not required. 
Duplicate tests (same id, date and test value) are removed here. 

```{R FCAL merge}
fcal <- fcal[, c("ids",
                 "COLLECTION_DATE",
                 "TEST_DATA",
                 "sex",
                 "diagnosis",
                 "diagnosis_date")]

fcal <- subset(fcal, ids %in% dict$ids)

# Collection dates include collection times which are not required. Discarding.

fcal$COLLECTION_DATE <- readr::parse_date(
  stringr::str_split_fixed(fcal$COLLECTION_DATE, " ", n = 2)[, 1],
  format = "%Y-%m-%d"
) 

colnames(fcal)[1:3] <- c("ids", "calpro_date", "calpro_result")

fcal <- subset(fcal, ids %in% dict$ids)
fcal <- fcal %>%
  select(-diagnosis)

fcal <- merge(fcal,
              dict[, c("ids", "diagnosis", "date.of.diag")],
              by = "ids",
              all.x = TRUE)

dim(fcal)
```

### Pre-processing of test results

FC data can be both left and right censored. FC recorded as "\<20" were
mapped to "20". FC recorded as "\>1250", "\>2500", or "\>6000" were all
mapped to "1250". Any FC tests given an error code (e.g. marked as an 
insufficient sample by the laboratory) have been removed.

::: {.callout-note collapse="true"}
#### More information on FC censoring

The lower limit of detection is $<20 \mu g/g$ ($20 \mu g$ of
calprotectin per $g$ of stool). By reducing the upper limit, it is
possible to run more tests in parallel. As a higher throughput has been
required over time, the upper threshold for tests has become lower.
Initially test results over $6000 \mu g/g$ were censored, then
$2500 \mu g/g$ and now $1250 \mu g /g$ is the upper limit for FC tests.
This change has resulted in minimal impact in clinics as $1250 \mu g/g$
is still considered a high result. However, this change has potential
implications for research.
:::

```{R FCAL censor mapping}
## Some values cannot be directly coerced as numeric
#unique(fcal$calpro_result[which(is.na(as.numeric(fcal$calpro_result)))])
unique(fcal$calpro_result[grepl("<", fcal$calpro_result)])
unique(fcal$calpro_result[grepl(">", fcal$calpro_result)])

fcal$calpro_result <- plyr::mapvalues(
  fcal$calpro_result,
  from = c(
    "<20",
    "<25",
    "<50",
    ">1250",
    ">2500",
    ">3000",
    ">6000"
  ),
  to = c(
    "20",
    "25",
    "50",
    "1250",
    "2500",
    "3000",
    "6000"
  )
)

# Sanity check to see that all values were converted
unique(fcal$calpro_result[grepl("<", fcal$calpro_result)])
unique(fcal$calpro_result[grepl(">", fcal$calpro_result)])

# Here, values that cannot be converted into a numeric value will be excluded
# (they are converted to NA)
fcal$calpro_result <- as.numeric(fcal$calpro_result) # Remove error codes
fcal <- fcal[!is.na(fcal[, "calpro_result"]), ]

# Apply limits of detection 
# range(fcal$calpro_result)
fcal[fcal[, "calpro_result"] < 20, "calpro_result"] <- 20
fcal[fcal[, "calpro_result"] > 1250, "calpro_result"] <- 1250
#range(fcal$calpro_result)
```

```{r fig-fcal-meas}
#| label: "fig-fcal-meas"
#| fig-cap: "Density plot of FCAL measurements by observed value"
#| warning: false
fcal %>%
  ggplot(aes(x = calpro_result)) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#9FD8CB",
    color = "#517664"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("FCAL (µg/g)") +
  ylab("Density") +
  geom_vline(xintercept = 250, colour = "red")
```

FC test results on the original measurement scale are heavily
right-skewed towards $100 \mu g/g$. These data will be log transformed-
resulting in the multi-modal distribution seen in @fig-logfcal-meas.

```{R}
#| label: "fig-logfcal-meas"
#| fig-cap: "Density plot of logged FCAL test results"
fcal %>%
  ggplot(aes(x = log(calpro_result))) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#9FD8CB",
    color = "#517664"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("log(FCAL (µg/g))") +
  ylab("Density") +
  geom_vline(xintercept = log(250), colour = "red")
```

### Removal of duplicate FCAL measurements

<!--- CAV: explain what you are doing in this section. Note that I removed the
early code for duplicate removal, as it should be covered by the code below ---> 


<!--- CAV: this chunk with fuzzy.duplicated.ids can be removed, no? --->  
```{R}
fuzzy.duplicated.ids <- c()

for (id in unique(fcal$ids)) {
  sub.fcal <- subset(fcal, ids == id) # Get FC data for a subject
  sub.fcal <- sub.fcal[order(sub.fcal$calpro_date), ] # Order by dates
  time.diff <- diff(sub.fcal$calpro_date) # Find time between ordered dates
  value.diff <- diff(sub.fcal$calpro_result) # Find difference in observed values
  # If two measurements are within 10 days of each other and have nearly same value
  if (any(time.diff <= 10 & abs(value.diff) <= 20)) {
    fuzzy.duplicated.ids <- c(fuzzy.duplicated.ids, id)
  }
}

message("There are ",
        length(fuzzy.duplicated.ids),
        " subjects who appear to have fuzzy duplicated FC measurements")
```


```{R}
duplicated.ids <- c()

for (id in unique(fcal$ids)) {
  sub.fcal <- subset(fcal, ids == id) # Get FC data for a subject
  sub.fcal <- sub.fcal[order(sub.fcal$calpro_date), ] # Order by dates
  time.diff <- diff(sub.fcal$calpro_date) # Find time between ordered dates
  value.diff <- diff(sub.fcal$calpro_result) # Find difference in observed values
  # If two measurements are within 10 days of each other and have the same value
  if (any(time.diff <= 10 & value.diff == 0)) {
    duplicated.ids <- c(duplicated.ids, id)
    # Remove suspected duplicates (taking into account difference is lagged)
    sub.fcal <- sub.fcal[c(TRUE, !(time.diff <= 10 & value.diff == 0)), ]
    # Remove data for subject with duplicates
    fcal <- subset(fcal, ids != id)
    # Add non duplicated data back
    fcal <- rbind(fcal, sub.fcal)
  }
}

message("There are ",
        length(duplicated.ids),
        " subjects who appear to have duplicated FC measurements")
```

<!--- CAV: remove as similar plot is shown below 
### Observations per subject

Although we explore the number of observations per subject in this
section, we will not yet apply the inclusion criteria of having at least
three FC measurements. This is because [we
later](#at-least-three-measurements-maximum-followup) reduce the maximum
follow-up which will impact the number of observations per subject.

The number of FC measurements per subject is right-skewed
(@fig-fcal-dist). However, there are also subjects with many FC
observations. These subjects were investigated and found to often have a
complex disease course, such as acute severe ulcerative colitis, and
required close monitoring as a result.

```{R Number of FCAL observations per subject}
#| label: fig-fcal-dist
#| fig-cap: "Distribution of number of FC measurements per subject. The red line indicates the required minimum number of observations for inclusion"

FCcounts <- as.vector(table(fcal$ids))
FCcountsdf <- tibble(ids = names(table(fcal$ids)), counts = FCcounts)
FCcountsdf %>%
  ggplot(aes(x = counts)) +
  geom_histogram(binwidth = 1, fill = "#887C9B") +
  geom_vline(xintercept = 2.5, color = "#D80032") +
  theme_minimal() +
  xlab("Number of FCAL observations per subject") +
  ylab("Count")
```

--->

<!--- CAV: remove this code, but keep as a back-up elsewhere 

### Number of FCAL measurements prior to diagnosis

We consider measurements taken more than 90 days before diagnosis. As it can be seen in 

```{r fcal before diagnosis}
fcal.sorted <- fcal %>% 
  mutate(days.from.diag = calpro_date - date.of.diag) %>%
  arrange(ids, calpro_date)
  

mydf <- fcal.sorted %>% 
  group_by(ids) %>%
  summarise(n.before.diag = sum(days.from.diag < -3*30),
            n.high.before.diag = sum(
              days.from.diag < -3*30 & calpro_result > 250
              )
            ) %>%
  arrange(desc(n.before.diag))

mydf %>%
  ggplot(aes(x = n.before.diag)) +
  geom_histogram(fill = "#887C9B") +
  theme_minimal() +
  ggtitle("Pre-diagnosis (> 90 days) FCAL observations per subject") + 
  xlab("Number of observations per subject") +
  ylab("Frequency")

mydf %>%
  ggplot(aes(x = n.high.before.diag)) +
  geom_histogram(fill = "#887C9B") +
  theme_minimal() +
  ggtitle("Pre-diagnosis (> 90 days) elevated FCAL observations per subject") + 
  xlab("Number of observations per subject") +
  ylab("Frequency")

table(mydf$n.before.diag)
table(mydf$n.high.before.diag)

# examine some examples
aux <- mydf$ids[mydf$n.high.before.diag == 5]
fcal.sorted %>% subset(ids %in% aux[1])
```

--->

### Retiming - part 1

Time of FC measurements were retimed and scaled to be the number of
years since IBD diagnosis.

```{R FCAL time mapping}
#| label: fig-fcal-spag-pre
#| fig-cap: "Spaghetti plot of FC trajectories (preprocessed)"

fcal <- merge(fcal, dict[,c("ids", "date.of.diag")], 
              by = "ids", all.x = TRUE, all.y = FALSE)

# Dates have already been converted to Date class by fix_date_char() for dict
fcal$calpro_time <- as.numeric(fcal$calpro_date - fcal$date.of.diag) / 365.25
dim(fcal)

# CAV: this line is not doing anything!
#fcal <- fcal[!is.na(fcal[, "calpro_time"]), ]

fcal %>%
  ggplot(aes(x = calpro_time, y = log(calpro_result), color = factor(ids))) +
  geom_line(alpha = 0.2) +
  geom_point(alpha = 0.6) +
  theme_minimal() +
  scale_color_manual(values = viridis::viridis(length(unique(fcal$ids)))) +
  guides(color = "none") +
  xlab("Time (years)") +
  ylab("Log(FCAL (µg/g))") +
  ggtitle("")
```

After retiming, it is clear some FC observations are earlier than
diagnosis and in some cases substantially earlier (@fig-fcal-spag-pre).
Tests taken close to reported date of diagnosis are likely "early" as a
result of diagnostic delay whereas tests from much earlier were likely
requested due to other conditions.

As such, FC results earlier than 90 days prior to diagnosis will be
discarded. If a subject has an FCAL within 90 days before diagnosis,
then all of their FCAL tests will be retimed such that their earliest FC
within this period is equal to 0 and all later measurements are shifted
accordingly to maintain the same differences between measurement times.

```{r remove prediag fcal}
fcal <- subset(fcal, calpro_time >= -0.25)
dim(fcal)
```

### Inclusion/exclusion: removal of subjects without a diagnostic FC test

As indicated in our inclusion/exclusion criteria, we reduce the dataset to only 
subjects with a diagnostic FC. This equates to subjects with at least one FCAL 
measurement within 3 months of diagnosis $t \leq 0.25$.

```{R FCAL retiming}
diagnostic <- fcal %>%
  group_by(ids) %>%
  summarise(n = sum(calpro_time < 0.25)) %>%
  subset(n > 0)

fcal <- subset(fcal, ids %in% diagnostic$ids)
dim(fcal)
```

After this exclusion, `r length(unique(fcal$ids))` remain in the data. 

### Retiming - part 2

Here, we show the distribution of the diagnostic FCAL measurements with
respect to diagnosis date (in days). 

```{r fcal days before diag}
p <- fcal %>% 
  group_by(ids) %>%
  filter(calpro_time == min(calpro_time)) %>%
  ggplot(aes(x = calpro_time * 365.25)) +
  geom_density(fill = "#20A39E", color = "#187370") +
  theme_minimal() +
  labs(y = "Density",
       x = "Time from diagnosis to first faecal calprotectin (days)") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red")

ggsave("plots/fc-diagnostic-dist.png",
       p,
       width = 16 * 2/3,
       height = 6,
       units = "in")
```

Although most diagnostic mearurements were observed around the recorded 
diagnosis time (mode near zero), this is not always the case. As such, we
decided to retime measurements/diagnosis time as described above (i.e. time = 0
matches the time of first available FCAL measurement). This is only applied to
individuals for which the first available CRP is prior to the recorded diagnosis
time.

```{R}
#| label: fig-fcal-spag-post
#| fig-cap: "Spaghetti plot of FC trajectories (processed)"
# Retime so that t_0 = 0.
for (id in unique(fcal$ids)) {
  temp <- subset(fcal, ids == id)
  if (any(temp$calpro_time < 0)) {
    add <- sort(temp$calpro_time)[1]
    fcal[fcal[, "ids"] == id, "calpro_time"] <-
      fcal[fcal[, "ids"] == id, "calpro_time"] + abs(add)
  }
}

length(unique(fcal$ids))

fcal %>%
  ggplot(aes(x = calpro_time, y = log(calpro_result), color = factor(ids))) +
  geom_line(alpha = 0.2) +
  geom_point(alpha = 0.6) +
  theme_minimal() +
  scale_color_manual(values = viridis::viridis(length(unique(fcal$ids)))) +
  guides(color = "none") +
  xlab("Time (years)") +
  ylab("Log(FCAL (µg/g))") +
  ggtitle("")
```

At this stage, we also exclude FCAL measurements recorded beyond 7-years post
diagnosis. 

```{r remove fcal after 7 years}
fcal <- subset(fcal, calpro_time <= 7)
dim(fcal)
length(unique(fcal$ids))
```

At this point, the data contains `r nrow(fcal)` FCAL measurements across all
`r length(unique(fcal$ids))` individuals. 

<!--- CAV: not sure why do you need this code as we don't really use fc.dist
anywhere else. If this is about saving the diagnostic FCAL values, you can 
match that by looking at the measurement such that time = 0 (after retiming) 

```{R, eval = FALSE}
##The following code is used to save the cleaned data generated so far. 

diag.time <- c()
fc.ids <-  unique(fcal$ids)

for (id in fc.ids) {
  temp <- subset(fcal, ids == id)
  temp <- temp[order(temp$calpro_time), ]
  diag.time <- c(diag.time, temp[1, "calpro_time"])
}


fc.dist <- data.frame(ids = fc.ids, diagnostic = diag.time)

if (!dir.exists(paste0(prefix, "processed"))) {
  dir.create(paste0(prefix, "processed"))
}

saveRDS(fc.dist, paste0(prefix, "processed/fc-diag-dist.RDS"))
```

---> 

### Inclusion/exclusion: a minimum number of FCAL measurements

Here, we summarise the number of observations per individual (with and without
considering censored values) as well as length of follow-up. The latter is 
defined as the difference (in years) between diagnosis time and the time of the 
latest FCAL measurement. 

```{r}
countsDF <- fcal %>%
  group_by(ids) %>%
  summarise(n.total = n(),
            censored.left = sum(calpro_result == 20),
            censored.right = sum(calpro_result == 1250),
            n.noncensored = n.total - censored.left - censored.right,
            n.negtime.nondiag = sum(calpro_time != 0 & calpro_date - date.of.diag < 0),
            followup = max(calpro_time))
```


```{R fcal followup pre exclusions}
#| label: fig-fcal-follow-up
#| fig-cap: "(A) Histogram of the number of FCAL measurements per subject. (B) Histogram of FCAL follow-up per subject (before exclusions). (C) Scatterplot with number of FCAL measurements vs follow-up."
p1 <- countsDF %>%
  ggplot(aes(x = n.total)) +
  geom_histogram(color = "black", fill = "#5BBA6F", binwidth = 1) +
  theme_minimal() +
  ylab("Count") +
  xlab("Measurements per subject")
# CAV: edit the plot below such that it doesn't show individual dots, you could e.g. use geom_hex
p2 <- countsDF %>%
  ggplot(aes(x = followup)) +
  geom_histogram(color = "black", fill = "#5BBA6F", binwidth = 1) +
  theme_minimal() +
  ylab("Count") +
  xlab("Follow-up (years)")
p3 <- countsDF %>%
  ggplot(aes(y = n.total, x = followup)) +
  geom_point(color = "#FF4F79", size = 2) +
  xlab("Follow-up (years since diagnosis)") + 
  ylab("Number of FCAL measurements") +
  theme_minimal() +
  geom_hline(yintercept = 3)

p1 + p2 + p3 + plot_annotation(tag_levels = 'A')
```

Summary observations:

- The number of FC measurements per subject is skewed towards low values. 
However, there are also subjects with many FC observations. These subjects were 
investigated and found to often have a complex disease course, such as acute 
severe ulcerative colitis, and required close monitoring as a result.
- We do not directly require a minimum follow-up for a subject as this may bias 
our findings. For example, UC patients who undergo a proctocolectomy
(surgical removal of the colon and rectum) are less likely to have FC
measurements after their surgery than patients who did not require
surgery. By applying criteria based on follow-up, we could indirectly
exclude subjects based on disease outcomes.
- However, the requirement of at least 3 FCAL measurements (within 7 years
from diagnosis) will indirectly remove individuals with a very short follow-up time. 

Note that our inclusion criteria requires at least 3 non-censored FCAL 
measurements per individual. As such, censoring needs to be taken into account
before applying filtering out individuals.


```{r}
p1 <- countsDF %>%
  ggplot(aes(x = n.noncensored)) +
  geom_histogram(color = "black", fill = "#5BBA6F", binwidth = 1) +
  theme_minimal() +
  ylab("Count") +
  xlab("Number of non-censored measurements per subject")

p2 <- countsDF %>%
  ggplot(aes(y = n.noncensored, x = followup)) +
  geom_point(color = "#FF4F79", size = 2) +
  xlab("Follow-up (years since diagnosis)") + 
  ylab("Number of non-censored FCAL measurements") +
  theme_minimal() +
  geom_hline(yintercept = 3)

p1 + p2 + plot_annotation(tag_levels = 'A')
```

```{R calculate number of non censored FCAL}
# Number of individuals with at least 3 FCAL measurements
sum(countsDF$n.total >= 3)

# Number of individuals with at least 3 non-censored FCAL measurements
sum(countsDF$n.noncensored >= 3)

# Number of individuals with at least 3 non-censored FCAL measurements after
# discarding non-diagnostic values with negative calpro_time
sum(countsDF$n.noncensored - countsDF$n.negtime.nondiag >= 3)
```

<!--- CAV: remove 

We now explore censored FC observations and begin by considering FC
results which have been left-censored ($\leq 20 \mu g/g$). From
@fig-left-censor-fcal, we can clearly see there are subjects with
entirely left-censored FC observations (n =
`r nrow(subset(countsDF, censored.left/count ==1))`).

```{R}
#| label: fig-left-censor-fcal
#| fig-cap: "Left-censored observations per subject"
#  Hold results for no. of measurements and no. of censored obs per subject
countsDF %>%
  ggplot(aes(x = censored.left / n.total, y = n.total)) +
  geom_point(alpha = 0.5, size = 0.9, color = "#70A288") +
  ylab("Total number of observations") +
  xlab("Proportion of left-censored observations") +
  theme_minimal() +
  theme(legend.position = "none") +
  geom_hline(yintercept = 3)
```

--->

The following is used to select individuals with at least 3 non-censored FCAL 
measurements. 

```{R FCAL frequency}
fcal <- fcal %>% 
  subset(ids %in% countsDF$ids[countsDF$n.noncensored >= 3])

length(unique(fcal$ids))
```

This leaves a cohort with `r length(unique(fcal$ids))` individuals.

```{r fcal followup post exclusions}
#| label: fig-fcal-follow-up
#| fig-cap: "(A) Histogram of the number of FCAL measurements per subject. (B) Histogram of FCAL follow-up per subject (before exclusions). (C) Scatterplot with number of FCAL measurements vs follow-up. In all cases, only individuals with at least 3 non-censored measurements are included."
p1 <- countsDF %>%
  subset(n.noncensored >= 3) %>% 
  ggplot(aes(x = n.total)) +
  geom_histogram(color = "black", fill = "#5BBA6F", binwidth = 1) +
  theme_minimal() +
  ylab("Count") +
  xlab("Measurements per subject")
# CAV: edit the plot below such that it doesn't show individual dots, you could e.g. use geom_hex
p2 <- countsDF %>%
  subset(n.noncensored >= 3) %>% 
  ggplot(aes(x = followup)) +
  geom_histogram(color = "black", fill = "#5BBA6F", binwidth = 1) +
  theme_minimal() +
  ylab("Count") +
  xlab("Follow-up (years)")
p3 <- countsDF %>%
  subset(n.noncensored >= 3) %>% 
  ggplot(aes(y = n.total, x = followup)) +
  geom_point(color = "#FF4F79", size = 2) +
  xlab("Follow-up (years since diagnosis)") + 
  ylab("Number of FCAL measurements") +
  theme_minimal() +
  geom_hline(yintercept = 3)

p1 + p2 + p3 + plot_annotation(tag_levels = 'A')
```

Review individuals with a very low followup

```{r very low followup FCAL}
# CAV: Nathan to check posterior probs for the subjects in this table
countsDF1 <- countsDF %>% 
  subset(n.noncensored >= 3 & followup < 0.5) %>% 
  arrange(followup)
countsDF1

fcal %>% 
  subset(ids %in% countsDF1$ids) %>% 
  arrange(ids, calpro_time)
```

<!--- CAV: this code is not needed as we set the max follow-up to 7;
save as a backup elsewhere

There are `r length(unique(fcal$ids))` subjects who have at least three
FC measurements available (before [reducing the maximum
followup](#maximum-followup)).

### Maximum followup {#maximum-followup}

A maximum follow-up should be specified in the interest of constructing
robust models which are not heavily influenced by observations at the
end of follow-up where observations are more sparse. We also ensure a
subject is only included if they have at least three FC measurements
during the restricted follow-up.

The decision for a specific cut-off is based upon two tables.
@tbl-follow-up explores how increasing the follow-up changes the mean,
median, and interquartile range of the number of observations per
subject. @tbl-count-fcal investigates how many subjects have at least
one FCAL after a set threshold.

```{R}
#| label: tbl-follow-up
#| tbl-cap: Statistics for number of observations across a range of maximum follow-up
years <- seq(1, 15, by = 1)
mean.n <- c()
median.n <- c()
IQR.n <- c()
freq <- c()

for (year in years) {
  # restrict to measurements within threshold
  temp <- subset(fcal, calpro_time <= year)
  # restrict to subjects with at least three measurements within threshold
  temp <- subset(temp, ids %in% as.numeric(names(table(temp$ids)[table(temp$ids) >= 3])))
  counts <- table(temp$ids)
  mean.n <- c(mean.n, round(mean(counts), 2))
  median.n <- c(median.n, median(counts))
  IQR.n <- c(IQR.n, paste(quantile(counts)[c(2, 4)], collapse = "-"))
  freq <- c(freq, length(names(counts)))
}

knitr::kable(
  data.frame(
    years = years,
    freq = freq,
    mean.n = mean.n,
    median.n = median.n,
    IQR.n = IQR.n
  )[5:15, ],
  col.names = c(
    "Year cut-off",
    "Number of subjects",
    "Mean",
    "Median",
    "IQR"
  )
)
```

```{R}
#| label: tbl-count-fcal
#| tbl-cap: "How many subjects have an FC available after a given number of years?"
count <- numeric()
for (year in years) {
  count <- c(count, length(unique(subset(fcal, calpro_time > year)$ids)))
}

count.tab <- data.frame(
  years = years,
  count = count
)
kable(count.tab, col.names = c("Years", "Number of subjects"))
```

From the above table, ten years of maximum follow-up appears to be the
most appropriate. However, we instead elect to use seven years of
maximum follow-up in order to [be consistent with
CRP](#maximum-followup-1)

```{R}
fcal <- subset(fcal, calpro_time <= 7)
# restrict to subjects with at least three measurements within threshold
fcal <- subset(
  fcal,
  ids %in% as.numeric(
    names(
      table(fcal$ids)[table(fcal$ids) >= 3]
    )
  )
)

n.4 <- length(
  unique(
    subset(
      fcal,
      ids %in% as.numeric(
        names(
          table(fcal$ids)[table(fcal$ids) >= 4]
          )
        )
      )$ids
    )
)


n.5 <- length(
  unique(
    subset(
      fcal,
      ids %in% as.numeric(
        names(
          table(fcal$ids)[table(fcal$ids) >= 5]
          )
        )
      )$ids
    )
)
```

### Censored observations

```{R Generate FCAL counts}
id.vector <- numeric()
count <- numeric()
censored.left <- numeric()
censored.right <- numeric()

for (id in unique(fcal$ids)) {
  fcal.subject <- subset(fcal, ids == id)
  id.vector <- c(id.vector, id)
  count <- c(count, nrow(fcal.subject))
  censored.left <- c(censored.left, sum(fcal.subject$calpro_result == 20))
  censored.right <- c(censored.right, sum(fcal.subject$calpro_result == 1250))
}

countsDF <- tibble(
  ids = id.vector,
  count = count,
  censored.left = censored.left,
  censored.right = censored.right
)
```

We now explore censored FC observations and begin by considering FC
results which have been left-censored ($\leq 20 \mu g/g$). From
@fig-left-censor-fcal, we can clearly see there are subjects with
entirely left-censored FC observations (n =
`r nrow(subset(countsDF, censored.left/count ==1))`).

```{R}
#| label: fig-left-censor-fcal
#| fig-cap: "Left-censored observations per subject"
#  Hold results for no. of measurements and no. of censored obs per subject
countsDF %>%
  ggplot(aes(x = censored.left / count, y = count)) +
  geom_point(alpha = 0.5, size = 0.9, color = "#70A288") +
  ylab("Total number of observations") +
  xlab("Proportion of left-censored observations") +
  theme_minimal() +
  theme(legend.position = "none")
```

Looking at right-censored observations (@fig-right-censor-fcal), we see
there are fewer subjects with a high proportion (\>50% of censored
observations). Nevertheless, there are still subjects with only right
censored observations (n =
`r nrow(subset(countsDF, censored.right/count ==1))`).

```{R}
#| label: fig-right-censor-fcal
#| fig-cap: "Right-censored observations per subject"
countsDF %>%
  ggplot(aes(
    x = censored.right / count, # Proportion censored
    y = count
  )) + # Total censored
  # Add jitter to better show distribution
  geom_point(alpha = 0.5, size = 0.9, color = "#D5896F") +
  ylab("Total number of observations") +
  xlab("Proportion of right-censored observations") +
  theme_minimal() +
  theme(legend.position = "none")
```

In line with our inclusion criteria, we exclude subjects with fewer than
three non-censored observations.

```{R}
keep <- countsDF[with(countsDF, count - (censored.left + censored.right) >= 3), ]
fcal <- subset(fcal, ids %in% keep$ids)
```

This results in a cohort size of `r length(unique(fcal$ids))`
(`r nrow(countsDF) - nrow(keep)` subjects removed).

--->

### Revisiting month of diagnosis

After filtering by subjects who have a diagnostic FC available, January
is no longer over-represented for month of diagnosis as we hypothesised
(@fig-diag-month-redux)

```{R Month of diagnosis (postprocessed)}
#| label: fig-diag-month-redux
#| fig-cap: "Bar plot of month of diagnosis"
dict.temp <- subset(dict, ids %in% unique(fcal$ids))
dict.temp %>%
  ggplot(aes(x = as.factor(month(date.of.diag, label = TRUE)))) +
  geom_bar(color = "black", fill = "#FEC601", linewidth = 0.3) +
  theme_minimal() +
  ylab("Frequency") +
  xlab("Month of IBD Diagnosis")
```

## C-reactive protein

C-reactive protein (CRP) is a blood-based marker of inflammation. Unlike
FCAL, which is highly specific to gastrointestinal inflammation, CRP
levels are indicative of overall inflammation and are more likely to be
affected by extra-intestinal factors such as infections. However,
patient adherence to CRP testing is very strong, and CRP has seen
historic usage in the field of IBD. Although CRP has been used for many
years, we unfortunately only have test results from as early as 2008 due
to the transition towards using TRAK for storing CRP results instead of
the previous system.

As there is only one extract for CRP data (obtained from TRAK), merging
multiple datasets is not required. As with the FCAL data, the recorded
time of day for each test has been discarded in favour of the date. Any
potential duplicate results have been removed.

```{R crp preprocess}
crp <- crp[, c("ids", "COLLECTION_DATE", "TEST_DATA")] %>%
  subset(ids %in% dict$ids)

# Collection dates include collection times which are not required. Discarding.
crp$COLLECTION_DATE <- readr::parse_date(
  stringr::str_split_fixed(crp$COLLECTION_DATE, " ", n = 2)[, 1],
  format = "%Y-%m-%d"
)

colnames(crp) <- c("ids", "crp_date", "crp_result")

crp <- merge(crp,
             dict[, c("ids", "diagnosis")],
             by = "ids",
             all.x = TRUE)
dim(crp)
```

### Pre-processing of test results

CRP is left-censored, but does not appear to be right-censored. Multiple
cut-offs are reported
(`r unique(as.numeric(gsub("<", "", names(table(crp$crp_result))[2:8])))`)
with there also being variations for how $< 1mg/L$ is reported
(`r names(table(crp$crp_result))[3:5]`). We map every observation $< 1$
to 1 and map \<2, \<3, and \< 5 to 2, 3, and 5 respectively. Any failed
tests (e.g due to contamination or an insufficient sample being
provided) are discarded. As such, $1mg/L$ is used as a left censoring value 
for CRP.

```{R crp censor mapping}
#| label: "fig-crp-meas"
#| fig-cap: "Density plot of FC measurements by observed value"
#| warning: false

unique(crp$crp_result[grepl("<", crp$crp_result)])
unique(crp$crp_result[grepl(">", crp$crp_result)])

# Remove censoring indicators
crp$crp_result <- as.numeric(
  plyr::mapvalues(
    crp$crp_result,
    from = c("<0.2", "<1", "<1.", "<1.0", "<2", "<3", "<3.0", "<5",
             ">90", ">320"),
    to = c(1, 1, 1, 1, 2, 3, 3, 5, 90, 320)
  )
)

# Lower-bound censoring
crp <- crp %>%
  mutate(crp_result = if_else(crp_result < 1, 1, crp_result))

# Remove error test results
crp <- crp[!is.na(crp[, "crp_result"]), ]
# Map numerical <1 test results (e.g 0.2) to 1.

crp %>%
  ggplot(aes(x = crp_result)) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#FFC800",
    color = "#FF8427"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("CRP (mg/L)") +
  ylab("Density")
```

As can be seen in @fig-crp-meas, extremely elevated CRP has been
observed in some cases. These observations are physiologically valid.
However, these data may skew our models and may be candidates for
removal.

As with the FCAL data, the CRP data is also log transformed
(@fig-logcrp-meas).

```{R}
#| label: "fig-logcrp-meas"
#| fig-cap: "Density plot of logged CRP test results"

# CAV: mode this to the end, at the same place in which you apply log-transform
# for FCAL. This means that you will need to change x = log(crp_result) in the
# used to generate the plot below.
crp$crp_result <- log(crp$crp_result)

crp %>%
  ggplot(aes(x = crp_result)) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#FFC800",
    color = "#FF8427"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("log(CRP (mg/L))") +
  ylab("Density")
```

Observing @fig-logcrp-meas, it would appear the influence of extremely
elevated CRP results will be minimal.

### Removal of duplicates

As multiple CRP measurements are possible within a short time-frame, we only 
consider as duplicates those with an exact match by `ids`, `crp_date` and
`crp_result`. 

```{r}
crp <- crp %>% distinct(ids,
  crp_date,
  crp_result,
  .keep_all = TRUE
)
dim(crp)
```

<!--- CAV: removed as similar analysis provided later. This follows the same 
structure as FCAL

### Observations per subject

As with FCAL, we explore the number of observations per subject in this
section. We do not yet apply the inclusion criteria of having at least
three CRP measurements.

```{R Number of CRP observations per subject}
#| label: fig-crp-dist
#| fig-cap: "Distribution of number of CRP measurements per subject. The pink line indicates the required minimum number of observations for inclusion"

CRPcounts <- as.vector(table(crp$ids))
CRPcountsdf <- tibble(counts = CRPcounts)
CRPcountsdf %>%
  ggplot(aes(x = counts)) +
  geom_histogram(binwidth = 1, fill = "#0081A7") +
  geom_vline(xintercept = 2.5, color = "#FF88DC") +
  theme_minimal() +
  xlab("Number of CRP observations per subject") +
  ylab("Count")
```

From @fig-crp-dist, we can see the strong patient adherence to CRP tests
[referred to earlier](#crp). Very few subjects (n =
`r sum(CRPcounts < 3)`) have fewer than three CRP measurements
available.

---> 


### Retiming - part 1

As with the FCAL data, the times of CRP measurements are retimed and
scaled to be the number of years since IBD diagnosis.

```{R CRP time mapping}
#| label: fig-crp-spag-pre
#| fig-cap: "Spaghetti plot of CRP trajectories (preprocessed)"

dim(crp)
crp <- merge(crp, dict[,c("ids", "date.of.diag")], 
             by = "ids", all.x = TRUE, all.y = FALSE)
dim(crp)

# Dates have already been converted to Date class by fix_date_char() for dict
crp$crp_time <- as.numeric(crp$crp_date - crp$date.of.diag) / 365.25

# CAV: this is doing nothing?
#crp <- crp[!is.na(crp[, "crp_time"]), ]

crp %>%
  ggplot(aes(x = crp_time, y = crp_result, color = factor(ids))) +
  geom_line(alpha = 0.2) +
  geom_point(alpha = 0.3) +
  theme_minimal() +
  scale_color_manual(values = viridis::viridis(length(unique(crp$ids)))) +
  guides(color = "none") +
  xlab("Time (years)") +
  ylab("Log(CRP (mg/L))") +
  ggtitle("")
```

As should be expected given the ubiquitous nature of CRP testing, many
CRP observations are earlier than diagnosis (@fig-crp-spag-pre). Tests
taken close to reported date of diagnosis are likely "early" as a result
of diagnostic delay whereas tests from much earlier were likely
requested due to other conditions.

As with FCAL, CRP results earlier than 90 days prior to diagnosis will
be discarded. If a subject has a CRP within 90 days before diagnosis,
then all of their CRP tests will be retimed such that their earliest CRP
within this period is equal to 0 and all later measurements are shifted
accordingly to maintain the same differences between measurement times.

::: callout-note
This may mean $t_0$ corresponds to slightly different dates across FCAL
and CRP for the same subject.
:::

We also reduce the dataset to only subjects with a diagnostic CRP which
equates to subjects with a CRP measurement within 3 months of diagnosis
$t \leq 0.25$

```{r}
crp <- subset(crp, crp_time >= -0.25)
dim(crp)
```

### Inclusion/exclusion: removal of subjects without a diagnostic CRP test

As indicated in our inclusion/exclusion criteria, we reduce the dataset to only 
subjects with a diagnostic FC. This equates to subjects with at least one FCAL 
measurement within 3 months of diagnosis $t \leq 0.25$.

```{R CRP retiming}
diagnostic <- crp %>%
  group_by(ids) %>%
  summarise(n = sum(crp_time < 0.25)) %>%
  subset(n > 0)

crp <- subset(crp, ids %in% diagnostic$ids)
dim(crp)
```

After this exclusion, `r length(unique(crp$ids))` remain in the data. 

### Retiming - part 2

Here, we show the distribution of the diagnostic CRP measurements with
respect to diagnosis date (in days). 

```{r crp days before diag}
p <- crp %>% 
  group_by(ids) %>%
  filter(crp_time == min(crp_time)) %>%
  ggplot(aes(x = crp_time * 365.25)) +
  geom_density(fill = "#415A77", color = "#1B263B") +
  theme_minimal() +
  labs(y = "Density",
       x = "Time from diagnosis to first CRP (days)") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red")

ggsave("plots/crp-diagnostic-dist.png",
       p,
       width = 16 * 2/3,
       height = 6,
       units = "in")
```

Similar to what was observed for FCAL, most diagnostic measurements were around 
the recorded diagnosis time (mode near zero). Here, we also retime 
measurements/diagnosis time as described above (i.e. time = 0
matches the time of first available CRP measurement). This is only applied to
individuals for which the first available CRP is prior to the recorded diagnosis
time.

<!--- CAV: this code is no longer needed, but I didn't remove it in case you
are for any reason using the saved "processed/crp-diag-dist.RDS" file

```{R}
diag.time <- c()
crp.ids <-  unique(crp$ids)

for (id in crp.ids) {
  temp <- subset(crp, ids == id)
  temp <- temp[order(temp$crp_time), ]
  diag.time <- c(diag.time, temp[1, "crp_time"])
}

crp.dist <- data.frame(ids = crp.ids, diagnostic = diag.time)
saveRDS(crp.dist, paste0(prefix, "processed/crp-diag-dist.RDS"))

p <-  crp.dist %>%
  ggplot(aes(x = diagnostic * 365.25)) +
  geom_density(fill = "#415A77", color = "#1B263B") +
  theme_minimal() +
  labs(y = "Density",
       x = "Time from diagnosis to first CRP (days)") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red")
ggsave("plots/crp-diagnostic-dist.png",
       p,
       width = 16 * 2/3,
       height = 6,
       units = "in")
```

---> 

```{R}
# Retime so that t_0 = 0.
for (id in unique(crp$ids)) {
  temp <- subset(crp, ids == id)
  if (any(temp$crp_time < 0)) {
    add <- sort(temp$crp_time)[1]
    crp[crp[, "ids"] == id, "crp_time"] <-
      crp[crp[, "ids"] == id, "crp_time"] + abs(add)
  }
}

length(unique(crp$ids))

crp %>%
  ggplot(aes(x = crp_time, y = crp_result, color = factor(ids))) +
  geom_line(alpha = 0.2) +
  geom_point(alpha = 0.3) +
  theme_minimal() +
  scale_color_manual(values = viridis::viridis(length(unique(crp$ids)))) +
  guides(color = "none") +
  xlab("Time (years)") +
  ylab("Log(CRP (mg/L))") +
  ggtitle("")
```

At this stage, we also exclude CRP measurements recorded beyond 7-years post
diagnosis. 

```{r remove crp after 7 years}
crp <- subset(crp, crp_time <= 7)
dim(crp)
length(unique(crp$ids))
```

At this point, the data contains `r nrow(fcal)` FCAL measurements across all
`r length(unique(fcal$ids))` individuals. 

### Additional pre-processing

TBC

### Inclusion/exclusion: a minimum number of CRP measurements

Here, we summarise the number of observations per individual (with and without
considering censored values) as well as length of follow-up. The latter is 
defined as the difference (in years) between diagnosis time and the time of the 
latest CRP measurement. 

```{r}
countsDF <- crp %>%
  group_by(ids) %>%
  summarise(n.total = n(),
            censored.left = sum(crp_result == 1),
            n.noncensored = n.total - censored.left,
            n.negtime.nondiag = sum(crp_time != 0 & crp_date - date.of.diag < 0),
            followup = max(crp_time))
```


```{R crp followup pre exclusions}
#| label: fig-fcal-follow-up
#| fig-cap: "(A) Histogram of the number of CRP measurements per subject. (B) Histogram of CRP follow-up per subject (before exclusions). (C) Scatterplot with number of CRP measurements vs follow-up."
p1 <- countsDF %>%
  ggplot(aes(x = n.total)) +
  geom_histogram(color = "black", fill = "#5BBA6F", binwidth = 1) +
  theme_minimal() +
  ylab("Count") +
  xlab("Measurements per subject")
# CAV: edit the plot below such that it doesn't show individual dots, you could e.g. use geom_hex
p2 <- countsDF %>%
  ggplot(aes(x = followup)) +
  geom_histogram(color = "black", fill = "#5BBA6F", binwidth = 1) +
  theme_minimal() +
  ylab("Count") +
  xlab("Follow-up (years)")
p3 <- countsDF %>%
  ggplot(aes(y = n.total, x = followup)) +
  geom_point(color = "#FF4F79", size = 2) +
  xlab("Follow-up (years since diagnosis)") + 
  ylab("Number of FCAL measurements") +
  theme_minimal() +
  geom_hline(yintercept = 3)

p1 + p2 + p3 + plot_annotation(tag_levels = 'A')
```

Our observations are very similar to what we had for FCAL. However, as CRP
measurement frequency is higher, we find a lower proportion of individuals with
a low follow-up time. 

Note that our inclusion criteria requires at least 3 non-censored FCAL 
measurements per individual. As such, censoring needs to be taken into account
before applying filtering out individuals.


```{r}
p1 <- countsDF %>%
  ggplot(aes(x = n.noncensored)) +
  geom_histogram(color = "black", fill = "#5BBA6F", binwidth = 1) +
  theme_minimal() +
  ylab("Count") +
  xlab("Number of non-censored measurements per subject")

p2 <- countsDF %>%
  ggplot(aes(y = n.noncensored, x = followup)) +
  geom_point(color = "#FF4F79", size = 2) +
  xlab("Follow-up (years since diagnosis)") + 
  ylab("Number of non-censored FCAL measurements") +
  theme_minimal() +
  geom_hline(yintercept = 3)

p1 + p2 + plot_annotation(tag_levels = 'A')
```

```{R calculate number of non censored FCAL}
# Number of individuals with at least 3 FCAL measurements
sum(countsDF$n.total >= 3)

# Number of individuals with at least 3 non-censored FCAL measurements
sum(countsDF$n.noncensored >= 3)

# Number of individuals with at least 3 non-censored FCAL measurements after
# discarding non-diagnostic values with negative calpro_time
sum(countsDF$n.noncensored - countsDF$n.negtime.nondiag >= 3)
```

### Minimum followup

As a reminder, we do not require a minimum follow-up for a subject as
this may bias our findings.

```{R}
#| label: fig-crp-follow-up
#| fig-cap: "Histogram of CRP follow-up per subject"
tab <- matrix(ncol = 2, nrow = 0)
colnames(tab) <- c("ids", "Followup")
for (id in unique(crp$ids)) {
  followup <- max(subset(crp, ids == id)$crp_time)
  tab <- rbind(tab, c(id, followup))
}

tab <- as.data.frame(tab)

tab |>
  ggplot(aes(x = Followup)) +
  geom_histogram(color = "black", fill = "#B38D97", binwidth = 1) +
  theme_minimal() +
  ylab("Count") +
  xlab("Followup (years)")
```

We have also plotted number of CRP measurements for each subject against
their follow-up to explore the relationship between these two attributes
(@fig-n-crp).

```{R}
#| label: fig-n-crp
#| fig-cap: "Number of CRP measurements against follow-up for each subject"
tab.temp <- tab
hmm <- data.frame(
  ids = names(table(crp$ids)),
  n = as.vector(table(crp$ids))
)
tab.temp <- merge(tab.temp, hmm, by = "ids")
tab.temp %>%
  ggplot(aes(y = n, x = Followup)) +
  geom_point(color = "#216869", size = 2) +
  ylab("Number of CRP measurements") +
  xlab("Follow-up (years)") +
  theme_minimal()
```

### Measurement frequency

We require a subject to have at least three CRP measurements across the
follow-up period to meet our inclusion criteria.

```{R CRP frequency}
crp <- subset(
  crp,
  ids %in% as.numeric(
    names(
      table(crp$ids)[table(crp$ids) >= 3]
    )
  )
)
```

There are `r length(unique(crp$ids))` subjects who have at least three
CRP measurements available (before [reducing the maximum
followup](#maximum-followup-1)).

### Maximum followup {#maximum-followup-1}

A maximum follow-up should be specified in the interest of constructing
robust models which are not heavily influenced by observations at the
end of follow-up where observations are more sparse. These two
requirements are dependent on one another as the maximum follow-up
affects whether or not a subject has at least three measurements taken
within follow-up.

As with FCAL, the decision for a specific cut-off is based upon how
increasing follow-up changes the mean, median, and interquartile range
of the number of observations per subject (@tbl-follow-up-crp) and how
many subjects have CRP observations after set thresholds
(@tbl-count-crp).

```{R}
#| label: tbl-follow-up-crp
#| tbl-cap: Statistics for number of observations across a range of maximum follow-up
years <- seq(5, 15, by = 1)
mean.n <- c()
median.n <- c()
IQR.n <- c()
freq <- c()

for (year in years) {
  # restrict to measurements within threshold
  temp <- subset(crp, crp_time <= year)
  # restrict to subjects with at least three measurements within threshold
  temp <- subset(temp, ids %in% as.numeric(names(table(temp$ids)[table(temp$ids) >= 3])))
  counts <- table(temp$ids)
  mean.n <- c(mean.n, round(mean(counts), 2))
  median.n <- c(median.n, median(counts))
  IQR.n <- c(IQR.n, paste(quantile(counts)[c(2, 4)], collapse = "-"))
  freq <- c(freq, length(names(counts)))
}

knitr::kable(
  data.frame(
    years = years,
    freq = freq,
    mean.n = mean.n,
    median.n = median.n,
    IQR.n = IQR.n
  ),
  col.names = c(
    "Year cut-off",
    "Number of subjects",
    "Mean",
    "Median",
    "IQR"
  )
)
```

```{R}
#| label: tbl-count-crp
#| tbl-cap: "How many subjects have an CRP available after a given number of years?"
years <- seq(1, 15, by = 1)
count <- numeric()
for (year in years) {
  count <- c(count, length(unique(subset(crp, crp_time > year)$ids)))
}

count.tab <- data.frame(years = years, count = count)
kable(count.tab, col.names = c("Years", "Number of subjects"))
```

From the above table, seven years of maximum follow-up appears to be the
most appropriate.

```{R}
crp <- subset(crp, crp_time <= 7)
# restrict to subjects with at least three measurements within threshold
crp <- subset(
  crp,
  ids %in% as.numeric(
    names(
      table(crp$ids)[table(crp$ids) >= 3]
    )
  )
)
```

### Additional pre-processing

As can be seen in @fig-crp-sample, the CRP data exhibits substantial
noise and there are many data points which can substantially increase
running times when fitting models. As such, we have taken the step to
pre-process the data by grouping FCAL observations into time intervals
for each subject and using the median where there are multiple
observations.

```{R}
#| label: fig-crp-sample
#| fig-cap: "CRP trajectories for a random sample of 15 subjects"
ids.sample <- sample(unique(crp$ids), 15)
crp.sub <- subset(crp, ids %in% ids.sample)

crp.sub %>%
  ggplot(aes(x = crp_time, y = crp_result, color = factor(ids))) +
  geom_line(alpha = 0.2) +
  geom_point(alpha = 0.3) +
  theme_minimal() +
  scale_color_manual(values = colorspace::darken(
    rainbow(15), amount = 0.4)
    ) +
  guides(color = "none") +
  xlab("Time (years)") +
  ylab("Log(CRP (mg/L))") +
  ggtitle("")
```

```{R}
#| label: fig-crp-sample-ma
#| fig-cap: "CRP trajectories after additional pre-processing for a random sample of 15 subjects"

id.list <- unique(crp$ids)
crp.ma <- matrix(NA, nrow = length(id.list), ncol = 7)

for (i in seq_along(id.list)) {
  subject_data <- subset(crp, ids == id.list[i])
  for (j in seq(0, 6)) {
    if (j == 6) {
      sub.obs <- subset(
        subject_data,
        crp_time >= j - 0.5 & crp_time <= j + 1
      )
    } else {
      sub.obs <- subset(
        subject_data,
        crp_time >= j - 0.5 & crp_time < j + 0.5
      )
    }
    if (nrow(sub.obs) > 0) {
      crp.ma[i, j + 1] <- median(sub.obs$crp_result)
    }
  }
}

rownames(crp.ma) <- id.list

crp.ma  <- crp.ma [rowSums(is.na(crp.ma)) <= 4, ]

id.list <- rownames(crp.ma)

crp.ma <- reshape2::melt(t(crp.ma ), id.vars = row.names(crp.ma ), na.rm = TRUE)
colnames(crp.ma) <- c("crp_time", "ids", "crp_result")
crp.ma  <- crp.ma[, c(2, 3, 1)]


crp.ma$crp_time <- crp.ma$crp_time - 1

# Take into account uneven spacing at start and end
crp.ma$crp_time <- plyr::mapvalues(crp.ma$crp_time,
  from = c(0, 6),
  to = c(0.25, 6.25)
)


# Add diagnosis type back
crp.ma <- merge(crp.ma, dict[, -3], by = "ids", all.x = TRUE, all.y = FALSE)


##########################
#--     Plotting       --#
##########################

p <- subset(crp.ma, ids %in% sample(unique(crp.ma$ids), 20)) %>%
  ggplot(aes(x = crp_time, y = crp_result, color = as.factor(ids))) +
  geom_point(alpha = 0.6) +
  geom_line(alpha = 0.6) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("Median Log (CRP)") +
  xlab("Time")
ggsave("plots/crp-med-traj.png", p, width = 10, height = 5, units = "in")
print(p)
```

It appears from @fig-crp-sample-ma that some subjects have the same
median log-transformed CRP across all of their observations, effectively
having a variance of 0. These subjects will be extracted and considered
as their own cluster, as they may cause numerical issues when model
fitting but remain of note.

```{R}
var0.ids <- c()
for (id in unique(crp.ma$ids)) {
  temp <- subset(crp.ma, ids == id)
  if (var(temp[, "crp_result"]) == 0) {
    var0.ids <- c(var0.ids, id)
  }
}
```

There are `r length(var0.ids)` subjects with no variation in their
preprocessed CRP observations. Interestingly, these subjects typically
exhibit substantial intra-subject heterogeneity for FC profiles
(@fig-FC-sample-crp-var). The CRP for these subjects will not be
modelled via LCMM.

```{R}
#| label: fig-FC-sample-crp-var
#| fig-cap: "Logged FC profiles for subjects with no variance across their CRP measurements."
#| results: "hold"
p <- subset(fcal, ids %in% var0.ids) %>%
  ggplot(aes(x = calpro_time, y = log(calpro_result), color = as.factor(ids))) +
  geom_point(alpha = 0.6) +
  geom_line(alpha = 0.6) +
  theme_minimal() + 
  theme(legend.position = "none") +
  ylab("Log (FC)") +
  xlab("Time")
ggsave("plots/fcal-for-crp0var.png", p, width = 10, height = 5, units = "in")
print(p)
crp.ma <- subset(crp.ma, !(ids %in% var0.ids))
```

```{R}
p1 <- crp.ma %>%
  ggplot(aes(x = exp(crp_result))) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#EE92C2",
    color = "#7B5D6F"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("CRP (mg/L)") +
  ylab("Density")

p2 <- crp.ma %>%
  ggplot(aes(x = crp_result)) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#ADF1D2",
    color = "#50635A"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("log(CRP (mg/L))") +
  ylab("Density")

print(p1 + p2)

ggsave("plots/crp-dist-ma.pdf", p1 + p2, width = 8, height = 4.5, units = "in")
```

There are `r nrow(crp.ma)` total data points after the additional
preprocessing describing `r length(unique(crp.ma$ids))` subjects.

```{R}
#| label: tbl-crp-ma-freq
#| tbl-cap: "Quantiles for number of CRP observations per subject after additional preprocessing."
crp.ma %>%
  select(ids) %>%
  table() %>%
  quantile()
```

### Revisiting month of diagnosis

After filtering by subjects who have a diagnostic CRP available, January
is no longer over-represented for month of diagnosis. This is a
comparable finding to FC (@fig-diag-month-redux).

```{R Month of diagnosis (postprocessed)}
#| label: fig-diag-month-redux-crp
#| fig-cap: "Bar plot of month of diagnosis"
dict.temp <- subset(dict, ids %in% unique(fcal$ids))
dict.temp %>%
  ggplot(aes(x = as.factor(month(date.of.diag, label = TRUE)))) +
  geom_bar(color = "black", fill = "#FEC601", linewidth = 0.3) +
  theme_minimal() +
  ylab("Frequency") +
  xlab("Month of IBD Diagnosis")
```

## Updated density plots

The following plots are updated versions of previous density plots
(@fig-fcal-meas, @fig-logfcal-meas, @fig-crp-meas and @fig-logcrp-meas).
These plots only include subjects who have met the inclusion criteria.

```{R Updated FCAL distribution}
#| label: "fig-fcal-meas-update"
#| fig-cap: "Updated density plot of FC measurements by observed value"
#| warning: false

p1 <- fcal %>%
  ggplot(aes(x = calpro_result)) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#2E86AB",
    color = "#07004D"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("FC (µg/g)") +
  ylab("Density")
print(p1)
```

```{R}
#| label: "fig-logfcal-meas-update"
#| fig-cap: "Updated density plot of logged FC test results"
p2 <- fcal %>%
  ggplot(aes(x = log(calpro_result))) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#F7A072",
    color = "#936136"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("log(FC (µg/g))") +
  ylab("Density")
print(p2)

ggsave("plots/fcal-dist.pdf", p1 + p2, width = 8, height = 4.5, units = "in")
```

```{R Updated CRP distribution}
#| label: "fig-crp-meas-update"
#| fig-cap: "Updated density plot of CRP measurements by observed value"
#| warning: false
p3 <- crp %>%
  ggplot(aes(x = exp(crp_result))) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#EE92C2",
    color = "#7B5D6F"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("CRP (mg/L)") +
  ylab("Density")
print(p3)
```

```{R}
#| label: "fig-logcrp-meas-update"
#| fig-cap: "Updated density plot of logged CRP test results"
p4 <- crp %>%
  ggplot(aes(x = crp_result)) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#ADF1D2",
    color = "#50635A"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("log(CRP (mg/L))") +
  ylab("Density")
print(p4)
ggsave("plots/crp-dist.pdf", p3 + p4, width = 8, height = 4.5, units = "in")
```

```{R Updated CRP distribution}
#| label: "fig-crp-meas-processed"
#| fig-cap: "Updated density plot of CRP after additional preprocessing"
#| warning: false
p5 <- crp.ma %>%
  ggplot(aes(x = exp(crp_result))) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#EE92C2",
    color = "#7B5D6F"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("Processed CRP (mg/L)") +
  ylab("Density")
print(p5)
```

```{R}
#| label: "fig-logcrp-meas-processed"
#| fig-cap: "Updated density plot of logged CRP after additional preprocessing"
p6 <- crp.ma %>%
  ggplot(aes(x = crp_result)) +
  geom_density(
    linewidth = 0.8,
    alpha = 0.5,
    fill = "#ADF1D2",
    color = "#50635A"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  xlab("log(processed CRP (mg/L))") +
  ylab("Density")
print(p6)
ggsave("plots/crp-processed-dist.pdf",
       p5 + p6,
       width = 8,
       height = 4.5,
       units = "in")


p <- (p1 + p2) / (p5 + p6) +
  plot_annotation(tag_levels = "A") &
  theme(plot.tag = element_text(size = 18, face = "bold"))


ggsave("plots/Sup-Figure-1.pdf",
       p,
       width = 8,
       height = 8,
       units = "in")
```

## Updated trajectory plots

### FC

```{R}
ids.sample <- sample(unique(fcal$ids), 15)
fcal.sub <- subset(fcal, ids %in% ids.sample)

cairo_pdf("plots/fcal-traj.pdf", width = 8, height = 6)
fcal.sub %>%
  ggplot(aes(x = calpro_time, y = log(calpro_result), color = factor(ids))) +
  geom_line(alpha = 0.7) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_manual(values = colorspace::lighten(rainbow(length(ids.sample)),
    amount = -0.35
  )) +
  guides(color = "none") +
  xlab("Time (years)") +
  ylab("Log(FCAL (µg/g))") +
  ggtitle("")
invisible(dev.off())

fcal.sub %>%
  ggplot(aes(x = calpro_time, y = log(calpro_result), color = factor(ids))) +
  geom_line(alpha = 0.7) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_manual(values = colorspace::lighten(rainbow(length(ids.sample)),
    amount = -0.35
  )) +
  guides(color = "none") +
  xlab("Time (years)") +
  ylab("Log(FCAL (µg/g))") +
  ggtitle("")
```

### CRP {#crp}

```{R}
ids.sample <- sample(unique(crp$ids), 15)
crp.sub <- subset(crp.ma, ids %in% ids.sample)

cairo_pdf("plots/crp-traj.pdf", width = 8, height = 6)
crp.sub %>%
  ggplot(aes(x = crp_time, y = crp_result, color = factor(ids))) +
  geom_line(alpha = 0.7) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_manual(values = colorspace::lighten(rainbow(length(ids.sample)),
                                                  amount = -0.35
  )) +
  guides(color = "none") +
  xlab("Time (years)") +
  ylab("Log(CRP (mg/L))") +
  ggtitle("")
invisible(dev.off())

crp.sub %>%
  ggplot(aes(x = crp_time, y = crp_result, color = factor(ids))) +
  geom_line(alpha = 0.7) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  scale_color_manual(values = colorspace::lighten(rainbow(length(ids.sample)),
                                                  amount = -0.35
  )) +
  guides(color = "none") +
  xlab("Time (years)") +
  ylab("Log(CRP (mg/L))") +
  ggtitle("")
```

## Data saving

The processed subject dictionary and FC and CRP datasets have been saved
to files, so they can be used for the primary analysis.

```{R}
if (!dir.exists(paste0(prefix, "processed"))) {
  dir.create(paste0(prefix, "processed"))
}

fcal$calpro_result <- log(fcal$calpro_result)

saveRDS(dict, paste0(prefix, "processed/dict-initial.RDS"))
saveRDS(fcal, paste0(prefix, "processed/fcal.RDS"))
saveRDS(crp, paste0(prefix, "processed/crp.RDS"))
saveRDS(crp.ma, paste0(prefix, "processed/median-crp.RDS"))
```

## Acknowledgments {.appendix}

This work is funded by the Medical Research Council & University of
Edinburgh via a Precision Medicine PhD studentship (MR/N013166/1, to
**NC-C**).

## Author contributions {.appendix}

**NC-C** performed the processing and wrote the text. **NP**, **ML**,
curated and provided datasets. **KM-G**, **CWL**, and **CAV** provided
supervisory support and assisted with revisions.

## References {.appendix}

::: {#refs}
:::

## Reuse {.appendix}

Licensed by <a href="https://creativecommons.org/licenses/by/4.0/">CC
BY</a> unless otherwise stated.

##  {.appendix}

::: center
<img src="../../images/MRC_HGU_Edinburgh RGB.png" alt="MRC Human Genetics Unit logo" class="center" height="50px"/>
<img src="../../images/cgem-logo.png" alt="Centre for Genomic &amp; Experimental Medicine logo" height="50px"/>
:::

------------------------------------------------------------------------

## Session info {.appendix}

```{R Session info}
pander(sessionInfo())
```
