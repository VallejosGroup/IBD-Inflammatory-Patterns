#' Produce a heatmap of LCMM cluster assignments across multiple lcmm::hlme fit objects
#' @param models list containing objects generated by
#'   \code{\link[lcmm:hlme]{lcmm::hlme}}.
#' @param cores Numeric. Number of CPU cores to use. Defaults to maximum
#'   available.
#' @param png Logical. If \code{TRUE}, the heatmap will be saved to file as a
#'   PNG.
#' @param pdf Logical. If \code{TRUE}, the heatmap will be saved to file as a
#'   PDF.
#' @param file.name Character. File name (without extension) for saved heatmap
#'   files. Defaults to \code{"heatmap"}. Not used if \code{png} and \code{pdf}
#'   are both \code{FALSE}.
#' @param return.data Logical. If \code{TRUE}, the averaged co-cluster matrix
#'   will be returned.
#' @export
lcmmHeatmap <- function(models,
                        cores = NULL,
                        png = TRUE,
                        pdf = FALSE,
                        file.name = "heatmap",
                        return.data = FALSE) {
  clusters <- data.frame(ids = models[[1]]$pprob[, 1])

  for (i in 1:length(models)) {
    clusters <- merge(clusters, models[[i]]$pprob[, 1:2], by = "ids")
    colnames(clusters)[1 + i] <- paste0("method.", i)
  }

  if (is.null(cores)){
    cl <- parallel::makeForkCluster(parallel::detectCores())
  } else {
    cl <- parallel::makeForkCluster(cores)
  }

  doParallel::registerDoParallel(cl)


  co.clusters <- foreach::foreach(i = 1:length(models)) %dopar% {
    clusters.temp <- clusters[, c(1, 1 + i)]
    x <- matrix(0, nrow = nrow(clusters), ncol = nrow(clusters))
    for (j in 1:nrow(clusters)) {
      for (k in 1:nrow(clusters)) {
        if (clusters.temp[j, 2] == clusters.temp[k, 2]) {
          x[j, k] <- 1
        }
      } # else assign 0 (already 0 so skipping)
    }
    x
  }

  parallel::stopCluster(cl)

  co.cluster <- Reduce("+", co.clusters) / length(models)

  ComplexHeatmap::draw(
    ComplexHeatmap::Heatmap(co.cluster,
                          name = sprintf("Averaged\nconcordance"),
                          col = viridis::viridis(100),
                          show_row_dend = FALSE)
  )

  if (png) {
    png(paste0(file.name,".png"),
        width = 8,
        height = 6,
        units = "in",
        res = 300)
    ComplexHeatmap::draw(
    ComplexHeatmap::Heatmap(co.cluster,
                            name = sprintf("Averaged\nconcordance"),
                            col = viridis::viridis(100),
                            show_row_dend = FALSE)
    )
    grDevices::dev.off()
  }
  if (pdf) {
    pdf(paste0(file.name,".pdf"),
        width = 8,
        height = 6)
    ComplexHeatmap::draw(
    ComplexHeatmap::Heatmap(co.cluster,
                            name = sprintf("Averaged\nconcordance"),
                            col = viridis::viridis(100),
                            show_row_dend = FALSE,
                            use_raster = TRUE,
                            raster_device = "png",
                            raster_quality = 10)
    )
    grDevices::dev.off()
  }
  if (return.data) {
    return(co.cluster)
  }
}

#' Create co-clustering matrix for FCAL and CRP models
#' @param G Number of clusters assumed by both models
#' @param models.fcal List holding all \code{hlme} objects created from FCAL
#'   data
#' @param models.crp List holding all \code{hlme} objects created from CRP
#'   data
#' @param cutoff Logical, should only subjects assigned posterior cluster
#'   membership probabilities above a given threshold for both models be
#'   included?
#' @param threshold Numeric. The posterior probability of cluster membership
#'   cutoff required for a subject to be included in the plot. Only used if
#'   \code{cutoff = TRUE}
#' @export
compareClustering <- function(G,
                              models.fcal,
                              models.crp,
                              cutoff = FALSE,
                              threshold = 0.8) {
  ids <- NULL
  # Extract posterior probabilities
  fcal.pprob <- models.fcal[[G]]$pprob
  crp.pprob <- models.crp[[G]]$pprob

  if (cutoff) {
    fcal.pprob <- pprobCutoff(fcal.pprob, threshold)
    crp.pprob <- pprobCutoff(crp.pprob, threshold)
  }

  fcal.ids <- fcal.pprob$ids
  crp.ids <- crp.pprob$ids

  # Only IDs in both FCAL and CRP models
  ids.comb <- fcal.ids[fcal.ids %in% crp.ids]
  ids.comb <- ids.comb[order(ids.comb)]


  # Reduce datasets to only shared IDS
  fcal.prob <- subset(fcal.pprob, ids %in% ids.comb)
  fcal.prob <- fcal.prob[order(fcal.prob$ids), ] # Order by ID

  crp.prob <- subset(crp.pprob, ids %in% ids.comb)
  # Also order by ID (ensures subjects are in same row in both FCAL and CRP)
  crp.prob <- crp.prob[order(crp.prob$ids), ]

  # Matrix to hold co-clustering info
  mat <- matrix(0, nrow = length(ids.comb), ncol = length(ids.comb))
  colnames(mat) <- ids.comb
  rownames(mat) <- ids.comb

  # Matrices for just FCAL and CRP clustering
  mat.fcal <- mat
  mat.crp <- mat

  # FCAL
  for (i in seq_along(ids.comb)) { # Row i
    cluster <- fcal.prob[i, "class"]
    mat.fcal[i, ] <- ifelse(fcal.prob[, "class"] == cluster, 1, 0)
  }

  # CRP
  for (i in seq_along(ids.comb)) { # Row i
    cluster <- crp.prob[i, "class"]
    mat.crp[i, ] <- ifelse(crp.prob[, "class"] == cluster, 1, 0)
  }


  # Assign values to comparison co-cluster matrix
  # 0 means no co-clustering
  mat[mat.fcal == 1 & mat.crp == 0] <- 2 # Only co-clustered by FCAL
  mat[mat.fcal == 0 & mat.crp == 1] <- 1 # Only co-clustered by CRP
  mat[mat.fcal == 1 & mat.crp == 1] <- 3 # Co-clustered by both FCAL and CRP
  return(mat)
}

#' @noRd
pprobCutoff <- function(pprob, threshold) {
  inc <- c() # Logical vector used to select rows with pprob above threshold
  for (i in seq_len(nrow(pprob))) {
    # If posterior probability for assigned class is above threshold
    if (pprob[i, 2 + pprob[i, 2]] > threshold) {
      inc <- c(inc, TRUE)
    } else { # Not above threshold
      inc <- c(inc, FALSE)
    }
  }
  return (pprob[inc, ]) # Reduce to only subjects above threshold
}



