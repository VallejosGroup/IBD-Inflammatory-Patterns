#' Spaghetti plots of each class
#' @param data Data frame used to fit the LCMM(s).
#' @param models A list containing \code{\link{hlme}{lcmm}} S3 objects
#' @param G Numeric. How many classes does the model assume?
#' @param log Logical. Should plots be on log scale? Defaults to TRUE.
#' @param indi Logical. Should separate plots for each class be generated?
#'   Defaults to FALSE.
#' @param multi Logical. Should sub-plots for each class be plotted alongside
#'   each other? Defaults to TRUE.
#' @param tmax Numeric. Maximum observation period. Defaults to 10
#' @param ylim Character. What should the y-axis of the plots be scaled to fit?
#'   Either NULL (default), "data", "pred", or "conf". The default uses
#'   pre-determined values for FCAL and CRP
#' @param column Logical. Should all sub-plots be in a single column? Defaults
#'   to FALSE (two columns)
#' @param pprob.cutoff Posterior probability cut-off for subjects to be included
#'   as trajectories
#' @param mapping Numeric vector Giving the new ordering of sub-plots. One must
#'   take into account plots are generated by column - not row. If not specified
#'   then the default class numbers will be used.
#' @param sizes Logical. Should class sizes be given as plot titles?
#' @param save Logical. Should sub-figure labels be generated?
#' @param knots Logical. If TRUE, knot locations will be plotted as vertical
#'   lines. Defaults to FALSE
#' @param knot.type Character. How are knots placed? Either "quantiles"
#'   (default) or "equal" (equally spaced). Not used if \code{knots = FALSE}.
#' @param n.knots Numeric integer giving the number of knots used. Defaults to
#'   3. Not used if \code{knots = FALSE}.
#' @param grbf Logical. If \code{TRUE}, then the model is assumed to have been
#'   fitted using two Gaussian Radial basis functions. Defaults to FALSE (using
#'   natural cubic splines instead).
#' @param l Numeric. Length scale constant for the Gaussian radial basis
#'   functions (not used if \code{GRBF = FALSE})
#' @param color Character. Name of variable in \code{data} to use to colour
#'  lines and points corresponding to subjects. If NULL then lines and points
#'  will be grey.
#' @param clusters Logical. Are clusters given via a "class" column in
#'   \code{data}? Otherwise clusters are found from the \code{hlme} object in
#'   models[[G]]. Defaults to FALSE.
#' @param external Optional data frame providing mean cluster
#'   estimates from \code{\link{predictY}{lcmm}}. Intended to be used with
#'   outputs from models applied to an external cohort. Columns should be
#'   "time", "Ypred", "CI1", and "CI2".
#' @param var.time Character. Name of variable used for time. Either
#'   "calpro_time" or "crp_time" Also used to determine if the LCMM has been
#'   fitted for FCAL or CRP.
#' @export
spaghettiPlot <- function(data,
                          models,
                          G,
                          log = TRUE,
                          indi = FALSE,
                          multi = TRUE,
                          tmax = 10,
                          ylim = NULL,
                          column = FALSE,
                          pprob.cutoff = NA,
                          sizes = FALSE,
                          mapping = NULL,
                          save = FALSE,
                          knots = FALSE,
                          knot.type = "quantiles",
                          n.knots = 3,
                          grbf = FALSE,
                          l = 1,
                          color = NULL,
                          clusters = FALSE,
                          external = NULL,
                          var.time = "calpro_time") {
  data <- cutPostProb(data, models, G, pprob.cutoff)

  if (!is.null(ylim)) {
    if (!(ylim %in% c("data", "pred", "conf"))) {
      stop("`ylim` should be either 'data', 'pred', or 'conf'")
    }
  }

  if (!is.null(external)) {
    if (!is.data.frame(external)) {
      stop("`external` should be NULL or a data frame")
    }
  }

  if (indi) {
    spaghetti_plot_sub(
      data = data,
      models = models,
      G = G,
      log = log,
      multi = FALSE,
      tmax = tmax,
      ylim = ylim,
      column = column,
      sizes = sizes,
      mapping = mapping,
      knots = knots,
      knot.type = knot.type,
      n.knots = n.knots,
      grbf = grbf,
      l = l,
      color = color,
      clusters = clusters,
      external = external,
      var.time = var.time
    )
  }
  if (multi) {
    spaghetti_plot_sub(
      data = data,
      models = models,
      G = G,
      log = log,
      multi = TRUE,
      tmax = tmax,
      ylim = ylim,
      column = column,
      sizes = sizes,
      mapping = mapping,
      save = save,
      knots = knots,
      knot.type = knot.type,
      n.knots = n.knots,
      grbf = grbf,
      l = l,
      color = color,
      clusters = clusters,
      external = external,
      var.time = var.time
    )
  }
}

#' @noRd
cutPostProb <- function(data, models, G, pprob.cutoff) {
  ids <- NULL
  if (!is.na(pprob.cutoff)) {
    pprob.cutoffs <- c()
    for (subject in unique(models[[G]]$pprob$ids)) {
      temp <- subset(models[[G]]$pprob, ids == subject)
      pprob <- temp[, 2 + temp$class]
      if (pprob > pprob.cutoff) {
        pprob.cutoffs <- c(pprob.cutoffs, subject)
      }
    }
    data <- subset(data, ids %in% pprob.cutoffs)
  }
  return(data)
}

#' @noRd
spaghetti_plot_sub <- function(data,
                               models,
                               G,
                               multi = FALSE,
                               log,
                               unit,
                               tmax = 10,
                               ylim = ylim,
                               column,
                               sizes,
                               mapping,
                               save,
                               knots,
                               knot.type,
                               n.knots,
                               grbf = grbf,
                               l = l,
                               color,
                               clusters,
                               external,
                               var.time) {
  # Global vars
  layout <- ids <- .data <- calpro_result <- crp_result <- time <- cluster <-
    Ypred <- CI1 <- CI2 <- NULL

  labels <- labels$list[[G]]
  p <- list()

  # Set up the page
  # creates a grid of plots
  layout <- pushViewportMod(G = G, column = column)

  lcmm_uit <- predictLcmm(
    models = models,
    G = G,
    tmax = tmax,
    var.time = var.time,
    n.knots,
    grbf = grbf,
    l = l
  )

  if (is.null(mapping)) {
    mapping <- 1:G
  }

  for (g in mapping) {
    matchidx <- as.data.frame(which(layout == g, arr.ind = TRUE))

    if(clusters) {
      id.group <- models[[G]]$pprob[models[[G]]$pprob[, 2] == mapping[g], 1]
      data.sub <- subset(data, class == mapping[g])
    } else {
      id.group <- models[[G]]$pprob[models[[G]]$pprob[, 2] == mapping[g], 1]
      data.sub <- subset(data, ids %in% id.group)
    }

    if (!log) {
      if (var.time == "calpro_time") {
        # FCAL

        if (is.null(color)) {
          p[[g]] <- ggplot(
            data = data.sub,
            aes(
              x = .data[[var.time]],
              y = exp(calpro_result)
            )
          ) + geom_line(aes(group = ids), alpha = 0.1)
        } else {
          p[[g]] <- ggplot(
            data = data.sub,
            aes(
              x = .data[[var.time]],
              y = exp(calpro_result),
              color = .data[[color]]
            )
          ) + geom_line(aes(group = ids), alpha = 0.2)
        }


        p[[g]] <- p[[g]] +
          xlab("Time (years)") +
          ylab("FC (\u03BCg/g)")
      } else if (var.time == "crp_time") {
        # CRP
        if (is.null(color)) {
          p[[g]] <- ggplot(
            data = data.sub,
            aes(
              x = .data[[var.time]],
              y = exp(crp_result)
            )
          ) + geom_line(aes(group = ids), alpha = 0.1)
        } else {
          p[[g]] <- ggplot(
            data = data.sub,
            aes(
              x = .data[[var.time]],
              y = exp(crp_result),
              color = .data[[color]]
            )
          ) + geom_line(aes(group = ids), alpha = 0.2)
        }
        p[[g]] <- p[[g]] +
          xlab("Time (years)") +
          ylab("CRP (\u03BCg/mL)")
      }

      if (knots) {
        p[[g]] <- plotKnots(
          data = data,
          plot = p[[g]],
          knot.type = knot.type,
          n.knots = n.knots,
          var.time = var.time,
          tmax = tmax
        )
      }

      p[[g]] <- p[[g]] +
        theme_minimal() +
        geom_line(
          data = lcmm_uit,
          aes(
            x = time,
            y = exp(lcmm_uit[, paste0(
              "Ypred_class",
              mapping[g]
            )])
          ),
          linewidth = 1.5,
          col = "#005EB8"
        ) +
        geom_line(
          data = lcmm_uit,
          aes(
            x = time,
            y = exp(lcmm_uit[, paste0(
              "lower.Ypred_class",
              mapping[g]
            )])
          ),
          col = "#005EB8",
          lty = 2
        ) +
        geom_line(
          data = lcmm_uit,
          aes(
            x = time,
            y = exp(lcmm_uit[, paste0(
              "upper.Ypred_class",
              mapping[g]
            )])
          ),
          col = "#005EB8",
          lty = 2
        )
      if (sizes) {
        p[[g]] <- p[[g]] + ggtitle(paste("n =", length(id.group))) +
            theme(plot.title = element_text(hjust = 0.5))
      }
    } else { # Logged plots
      if (var.time == "calpro_time") {
        if (is.null(color)) {
          p[[g]] <- ggplot(
            data = data.sub,
            aes(
              x = .data[[var.time]],
              y = calpro_result
            )
          ) + geom_line(aes(group = ids), alpha = 0.1)
        } else {
          p[[g]] <- ggplot(
            data = data.sub,
            aes(
              x = .data[[var.time]],
              y = calpro_result,
              color = .data[[color]]
            )
          ) + geom_line(aes(group = ids), alpha = 0.2)
        }


        p[[g]] <- p[[g]] +
          geom_hline(
            yintercept = log(250),
            color = "#FFBF00",
            lty = 3,
            linewidth = 1.5
          ) +
          xlab("Time (years)") +
          ylab("Log (FC (\u03BCg/g))")

        if (!is.null(external)) {
          external.sub <- subset(external, cluster == g)
          p[[g]] <- p[[g]] +
            geom_line(aes(x = time, y = Ypred),
                      color = "#C8102E",
                      linewidth = 1.5,
                      data = external.sub) +
            geom_line(aes(x = time, y = CI1),
                      color = "#C8102E",
                      lty = 2,
                      data = external.sub) +
            geom_line(aes(x = time, y = CI2),
                      color ="#C8102E",
                      lty = 2,
                      data = external.sub)
        }

      } else if (var.time == "crp_time") {
        if (is.null(color)) {
          p[[g]] <- ggplot(
            data = data.sub,
            aes(
              x = .data[[var.time]],
              y = crp_result
            )
          ) + geom_line(aes(group = ids), alpha = 0.1)
        } else {
          p[[g]] <- ggplot(
            data = data.sub,
            aes(
              x = .data[[var.time]],
              y = crp_result,
              color = .data[[color]]
            )
          ) + geom_line(aes(group = ids), alpha = 0.2)
        }

        p[[g]] <- p[[g]] +
          geom_hline(
            yintercept = log(5),
            color = "#FFBF00",
            lty = 3,
            linewidth = 1.5
          ) +
          xlab("Time (years)") +
          ylab("Log (CRP (\u03BCg/mL))")

        if (!is.null(external)) {
          external.sub <- subset(external, cluster == g)
          p[[g]] <- p[[g]] +
            geom_line(aes(x = time, y = Ypred),
                      color = "#C8102E",
                      linewidth = 1.5,
                      data = external.sub) +
            geom_line(aes(x = time, y = CI1),
                      color = "#C8102E",
                      lty = 2,
                      data = external.sub) +
            geom_line(aes(x = time, y = CI2),
                      color ="#C8102E",
                      lty = 2,
                      data = external.sub)
        }

      }

      if (knots) {
        p[[g]] <- plotKnots(
          data = data,
          plot = p[[g]],
          knot.type = knot.type,
          n.knots = n.knots,
          var.time = var.time,
          tmax = tmax
        )
      }


      p[[g]] <- p[[g]] +
        theme_minimal()

      if (sizes) {
        p[[g]] <- p[[g]] + ggtitle(paste("n =", length(id.group))) +
          theme(plot.title = element_text(hjust = 0.5))
      }

      if (var.time == "calpro_time") {
        p[[g]] <- p[[g]] +
          geom_line(
            data = lcmm_uit,
            aes(
              x = time,
              y = lcmm_uit[, paste0(
                "Ypred_class",
                mapping[g]
              )]
            ),
            linewidth = 1.5,
            col = "#005EB8"
          ) +
          geom_line(
            data = lcmm_uit,
            aes(
              x = time,
              y = lcmm_uit[, paste0(
                "lower.Ypred_class",
                mapping[g]
              )]
            ),
            col = "#005EB8",
            lty = 2
          ) +
          geom_line(
            data = lcmm_uit,
            aes(
              x = time,
              y = lcmm_uit[, paste0(
                "upper.Ypred_class",
                mapping[g]
              )]
            ),
            col = "#005EB8",
            lty = 2
          )
      } else {
        p[[g]] <- p[[g]] +
          geom_line(
            data = lcmm_uit,
            aes(
              x = time,
              y = lcmm_uit[, paste0(
                "Ypred_class",
                mapping[g]
              )]
            ),
            linewidth = 1.5,
            col = "#005EB8"
          ) +
          geom_line(
            data = lcmm_uit,
            aes(
              x = time,
              y = lcmm_uit[, paste0(
                "lower.Ypred_class",
                mapping[g]
              )]
            ),
            col = "#005EB8",
            lty = 2
          ) +
          geom_line(
            data = lcmm_uit,
            aes(
              x = time,
              y = lcmm_uit[, paste0(
                "upper.Ypred_class",
                mapping[g]
              )]
            ),
            col = "#005EB8",
            lty = 2
          )
      }
    }

    p[[g]] <- setYlim(
      p = p[[g]],
      ylim = ylim,
      var.time = var.time,
      G = G,
      log = log,
      data = data,
      lcmm_uit = lcmm_uit
    )

    p[[g]] <- p[[g]] + theme(legend.position = "none")
    printLcmm(g = g, p = p, matchidx = matchidx, multi = multi, save = save)
  }
}

#' @noRd
pushViewportMod <- function(G, column) {
  if (column) {
    # use single column layout for sub-plots
    layout <- matrix(seq(1, G),
      ncol = 1,
      nrow = G
    )
  } else {
    # use two column layout for sub-plots
    layout <- matrix(seq(1, 2 * ceiling(G / 2)),
      ncol = 2,
      nrow = ceiling(G / 2)
    )
  }
  grid::pushViewport(grid::viewport(layout = grid::grid.layout(
    nrow(layout),
    ncol(layout)
  )))
  return(layout)
}


#' Set y axis limits based on pre-determined values, subject profiles,
#' mean cluster profiles point estimates, or 95% confidence intervals for the
#' mean trajectories
#' @noRd
setYlim <- function(p, ylim, var.time, G, log, data, lcmm_uit) {
  if (is.null(ylim)) {
    if (var.time == "calpro_time") {
      if (log) {
        p <- p + ylim(log(20), log(2500))
      } else {
        p <- p + ylim(0, 1250)
      }
    } else if (var.time == "crp_time") {
      if (log) {
        p <- p + ylim(-3, 8)
      } else {
        p <- p + ylim(0, 200)
      }
    }
  } else if (ylim == "data") {
    if (var.time == "calpro_time") {
      if (log) {
        p <- p + ylim(
          floor(min(data$calpro_result)),
          ceiling(max(data$calpro_result))
        )
      } else {
        p <- p + ylim(
          floor(min(exp(data$calpro_result))),
          ceiling(max(exp(data$calpro_result)))
        )
      }
    } else if (var.time == "crp_time") {
      if (log) {
        p <- p + ylim(
          floor(min(data$crp_result)),
          ceiling(max(data$crp_result))
        )
      } else {
        p <- p + ylim(
          floor(min(exp(data$crp_result))),
          ceiling(max(exp(data$crp_result)))
        )
      }
    }
  } else if (ylim == "pred") {
    if (log) {
      p <- p + ylim(
        floor(min(lcmm_uit[, 1:G])),
        ceiling(max(lcmm_uit[, 1:G]))
      )
    } else {
      p <- p + ylim(
        floor(min(exp(lcmm_uit[, 1:G]))),
        ceiling(max(exp(lcmm_uit[, 1:G])))
      )
    }
  } else if (ylim == "conf") {
    if (log) {
      p <- p + ylim(
        floor(min(lcmm_uit[, -ncol(lcmm_uit)])),
        ceiling(max(lcmm_uit[, -ncol(lcmm_uit)]))
      )
    } else {
      p <- p + ylim(
        floor(min(exp(lcmm_uit[, -ncol(lcmm_uit)]))),
        ceiling(max(exp(lcmm_uit[, -ncol(lcmm_uit)])))
      )
    }
  }
  return(p)
}



#' @noRd
predictLcmm <- function(models, G, tmax, var.time, n.knots, grbf, l) {
  time.cand <- seq(0, tmax, by = 0.01)
  data_pred <- data.frame(time.cand, diagnosis = "Crohn's Disease")
  data_pred <- rbind(
    data_pred,
    data.frame(time.cand, diagnosis = "Ulcerative Colitis")
  )
  colnames(data_pred) <- c(var.time, "diagnosis")
  data_pred$diagnosis <- as.factor(data_pred$diagnosis)


  if (grbf) {
    if (n.knots == 2) {
      centers <- c(7 / 3, 14 / 3)
      data_pred$grbf1 <- exp(-1 * ((data_pred$calpro_time - centers[1])^2) / (2 * l^2))
      data_pred$grbf2 <- exp(-1 * ((data_pred$calpro_time - centers[2])^2) / (2 * l^2))
    } else if (n.knots == 3) {
      centers <- c(7 / 4, 14 / 4, 21 / 4)
      data_pred$grbf1 <- exp(-1 * ((data_pred$calpro_time - centers[1])^2) / (2 * l^2))
      data_pred$grbf2 <- exp(-1 * ((data_pred$calpro_time - centers[2])^2) / (2 * l^2))
      data_pred$grbf3 <- exp(-1 * ((data_pred$calpro_time - centers[3])^2) / (2 * l^2))
    } else {
      stop("n.knots should be either 2 or 3.\n")
    }
  }

  pred <- lcmm::predictY(models[[G]],
    data_pred,
    var.time = var.time,
    draws = TRUE
  )
  lcmm_uit <- as.data.frame(pred$pred)
  lcmm_uit$time <- time.cand
  return(lcmm_uit)
}

#' @noRd
printLcmm <- function(g, p, matchidx, multi, save) {
  if (multi) {
    if (save) {
      # Add subfigure labels
      print(
        p[[g]] +
          ggtitle(labels[g]) +
          theme(plot.title = element_text(face = "bold", size = 20)),
        vp = grid::viewport(
          layout.pos.row = matchidx$row,
          layout.pos.col = matchidx$col
        )
      )
    } else {
      print(p[[g]],
        vp = grid::viewport(
          layout.pos.row = matchidx$row,
          layout.pos.col = matchidx$col
        )
      )
    }
  } else {
    print(p[[g]])
  }
}


plotKnots <- function(data, plot, knot.type, n.knots, var.time, tmax) {
  knots <- NULL
  if (knot.type == "quantiles") {
    knot.df <- data.frame(knots = attr(
      ns(data[[var.time]],
        df = n.knots + 1,
        Boundary.knots = c(0, tmax)
      ),
      "knots"
    ))
  } else if (knot.type == "equal") {
    knot.df <- data.frame(knots = attr(
      ns(data[[var.time]],
        df = n.knots + 1,
        knots = seq(
          from = tmax / (n.knots + 1),
          to = (tmax / (n.knots + 1)) * n.knots,
          by = tmax / (n.knots + 1)
        ),
        Boundary.knots = c(0, tmax)
      ),
      "knots"
    ))
  }
  return(plot + geom_vline(aes(xintercept = knots),
    data = knot.df,
    color = "#44ADB0"
  ))
}

labels <- new.env()
labels$list <- list()
labels$list[[1]] <- "A"
labels$list[[2]] <- c("A", "B")
labels$list[[3]] <- c("A", "C", "B")
labels$list[[4]] <- c("A", "C", "B", "D")
labels$list[[5]] <- c("A", "C", "E", "B", "D")
labels$list[[6]] <- c("A", "C", "E", "B", "D", "F")
labels$list[[7]] <- c("A", "C", "E", "G", "B", "D", "F")
labels$list[[8]] <- c("A", "C", "E", "G", "B", "D", "F", "H")
labels$list[[9]] <- c("A", "C", "E", "G", "I", "B", "D", "F", "H")
labels$list[[10]] <- c("A", "C", "E", "G", "I", "B", "D", "F", "H", "J")
labels$list[[11]] <- c("A", "C", "E", "G", "I", "K", "B", "D", "F", "H", "J")
labels$list[[12]] <- c("A", "C", "E", "G", "I", "K", "B", "D", "F", "H", "J", "L")



ScotBlue <- "#005EB8"
DanishRed <- "#C8102E"

